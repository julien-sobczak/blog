== How to create a package manually?

Linux packages are commonly available in a `.deb` and a `.rpm` file.footnote:[https://unix.stackexchange.com/questions/103531/what-are-deb-and-rpm-and-how-are-they-different-from-msi/103560]

* The `.deb` files are meant for distributions of Linux that derive from Debian (Ubuntu, Linux Mint, etc.).
* The `.rpm` files are used primarily by distributions that derive from Redhat based distros (Fedora, CentOS, RHEL).

[NOTE]
.Why two formats?
====
Because there are two main Linux distributions: Red Hat and Debian and each one has its own file formats: `.rpm` for Red Hat Package Manager and `.deb` for Debian.

Both package formats have a lot in common and we will only discuss Debian packages in this document. The following table summarizes the main differences between the archive files.

|===
|| .rpm | .deb

| Archive Format
| Uses the link:https://en.wikipedia.org/wiki/Cpio[`cpio` command and file format], that mostly disappears, replaced by the classic `tar` command.
| Uses the link:https://en.wikipedia.org/wiki/Ar_(Unix)[`ar`] command, also supersedes by the classic `tar` command.

| Package Manager
| `rpm`
| `dpkg`

| Frontend Package Manager
| `yum`
| `apt`

| Database
| `/var/lib/rpm`
| `/var/lib/dpkg`
|===
====

[NOTE]
.What You Need to Know About the Debian package format?
====
A `.deb` file is an `ar` archive (the `ar` command is an ancestor of the common `tar` command and was already present in the first Unix version in 1971! Now, this command is mainly used by Debian packages). This archives contains 3 files:

* `debian-binary`: A text file containing `2.0\n`. This states the version of the deb file format. For 2.0 all other lines get ignored.
* `data.tar.gz`: A `tar` archive containing all files that will be installed with their destination paths
[source]
----
./
./sbin/
./sbin/parted
./usr/
./usr/share/
./usr/share/man/
./usr/share/man/man8/
./usr/share/man/man8/parted.8.gz
./usr/share/doc/
./usr/share/doc/parted/
./usr/share/doc/parted/README.Debian
./usr/share/doc/parted/copyright
./usr/share/doc/parted/changelog.Debian.gz
./usr/share/doc/parted/changelog.gz
----
* `control.tar.gz`: A `tar` archive containing various files useful for the `dpkg` command to do its job: metadata about the package (`control`) including the list of required dependency, the md5 sums of every data file to check integrity (`md5sums`), and also maintainer scripts (ex: `postinst` for post-installation and `prerm` for pre-removal), which are executable scripts that must be run when installing or removing a package.
[source]
----
control
md5sums
postinst
prerm
----

Note that the command `dpkg --build` redirects to the command `dpkg-deb --build` and the command `dpkg --list` redirects to the command `dpkg-query --list`. The code of these commands is present in the same repository under the subdirectories `./dpkg-deb/` and `./src/querycmd.c` respectively.

_Further documentation_: link:https://raphaelhertzog.com/2010/11/08/5-reasons-why-a-debian-package-is-more-than-a-simple-file-archive/[5 reasons why a Debian package is more than a simple file archive, RaphaÃ«l Hertzog]
====

A package is a collection of files to distribute applications or libraries via the Debian package management system. The aim of packaging is to allow the automation of installing, upgrading, configuring, and removing computer programs in a consistent manner.

The main introduction to Debian packages can be found by installing a Debian package :) (the PDF is also available link:https://www.debian.org/doc/manuals/packaging-tutorial/packaging-tutorial.en.pdf[online]):

[source]
----
$ apt install packaging-tutorial
# Check /usr/share/doc/packaging-tutorial/packaging-tutorial.pdf
----

* The *official procedure to create a package* the "Debian way" is the link:https://www.debian.org/doc/manuals/maint-guide/[Debian New Maintainers' Guide].
* The complete *tutorial to create a package manually* is the link:https://tldp.org/HOWTO/html_single/Debian-Binary-Package-Building-HOWTO/[Debian Binary Package Building HOWTO],

Commands:

* `dpkg-buildpackage` is the de facto standard tool to build Debian source and binary packages. When Debian developers are talking about packages, they surely reference the source package. For this blog post, we will skip this building step and directly build the binary archive, which is the archive that really gets installed on your system.
* `dpkg-deb` packs, unpacks and provides information about Debian archives.
* `dpkg` to install and remove packages from your system.


[NOTE]
.What You Need to Know About the command `dpkg`?
====
The project Dpkg started in 1994, at the same time the Debian package format was created, and thus the command `dpkg` works only with `.deb` binary archives. You must provide the archive as the command does not know how to retrieve it by itself. The command manages a database stored under `/var/lib/dpkg` to keep note of everything that is installed on the server, which is essential to determine what to clean when you remove a package.

* Official Repository: https://git.dpkg.org/cgit/dpkg/dpkg.git
* GitHub Mirror: https://github.com/guillemj/dpkg
====


To illustrate this post, we will use the Hello World example present in the link:https://gobyexample.com/hello-world[Go by example tutorial].

[source,sh]
----
$ cat > hello.go << HERE
package main
import "fmt"
func main() {
    fmt.Println("hello world")
}
HERE
$ go run hello.go
hello world
$ env GOOS=linux GOARCH=amd64 go build hello.go # Make sure to build for Linux
$ ls
hello    hello.go
$ chmod +x hello
$ ./hello
hello world
----

Our goal is to package this binary and the most popular solution to build a Debian package for a Go program is the link:https://go-team.pages.debian.net/packaging.html[utility `dh-golang`]. As we want to use the most basic commands to get as close as possible to the process, we will use the standard `dpkg` command even if that means not building a world-class Debian package.


=== Prerequisites

To play safely with the package we are going to build, we will use a Debian virtual server to prevent damages to your system and to be able to recreate easily the environment from scratch. We use link:https://www.vagrantup.com/[Vagrant] to create this virtual machine. Make sure Vagrant is installed on your system by following the link:https://learn.hashicorp.com/tutorials/vagrant/getting-started-install?in=vagrant/getting-started[installation procedure] for your operating system.

INFO: There is a companion GitHub repository link:https://github.com/julien-sobczak/linux-packages-under-the-hood[julien-sobczak/linux-packages-from-scratch] to this blog post. This repository is optional for this article. It mostly contains a `Vagrantfile` to start the virtual machines, the files to create various Debian versions of the Debian hello package, and also the Golang code source that reimplement minimal versions of the `dpkg` and `apt` commands. You will find more information in the link:https://github.com/julien-sobczak/linux-packages-under-the-hood/blob/master/README.md[`README.md`] file of this repository.

Then:

[source, sh]
----
$ mkdir sandbox
$ cd sandbox
$ vagrant init
$ echo > Vagranfile <<EOF
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure("2") do |config|
  config.vm.box = "debian/bullseye64"
end
EOF
$ vagrant up
# wait a few minutes
$ vagrant ssh
vagrant$ uname -a
Linux bullseye 5.10.0-3-amd64 #1 SMP Debian 5.10.13-1 (2021-02-06) x86_64 GNU/Linux
----

When using Vagrant, the directory containing your `Vagrantfile` is accessible from the virtual machine from the directory `/vagrant`. We will use it to copy our `hello` binary program:

[source,sh]
----
$ ls
Vagrantfile
$ cp /path/to/hello .
$ vagrant ssh
vagrant$ cd /vagrant
vagrant$ ls
hello Vagrantfile
----

NOTE: All commands whose prompt starts with `vagrant#` must be run inside the virtual machine. If this prompt is not specified, run the commands from your host.

Great! We are ready to create a Debian package for our Hello program.

[source,sh]
----
vagrant# cd /vagrant/
vagrant# mkdir -p ./debian/usr/bin
vagrant# cp hello ./debian/usr/bin/
vagrant# mkdir -p ./debian/DEBIAN
vagrant# cat > ./debian/DEBIAN/control <<EOF
Package: hello
Version: 1.1-1
Section: base
Priority: optional
Architecture: amd64
Maintainer: Julien Sobczak
Description: Say Hello
EOF
----


[NOTE]
.What You Need to Know About the DEB822 Format
====
This format can be seen as an ancestor of YAML or JSON. Here is an example:

[source,deb822]
----
FieldSimple:
FieldFolded: very long value
 continuing on the next line starting with a space.
FieldMultiline:
 /usr/bin/cmd1
 /usr/bin/cmd2
----

The format is used by the file `control` but also by some files in the `dpkg` database such as `/var/lib/dpkg/status`.

Check the link:https://man7.org/linux/man-pages/man5/deb822.5.html[man page] for additional information.
====


To build using `dpkg`:

[source,sh]
----
$ apt install fakeroot # install the fakeroot command
$ fakeroot dpkg --build debian hello_1.1-1_amd64.deb
----

This command builds a Debian package, which as discussed before, consists in building an `ar` archive containing two `tar` archives: the content of our directory `DEBIAN/` in `control.tar.gz` and the other files in `data.tar.gz`. We can reproduce its working using standard Bash commands:footnote:[https://unix.stackexchange.com/questions/30303/how-to-create-a-deb-file-manually]

[source,sh]
----
$ apt install binutils # install the ar command
$ apt install fakeroot # install the fakeroot command
$ echo 2.0 > debian-binary
$ cd debian && tar czf ../data.tar.gz  [a-z]* && cd ..
$ cd debian/DEBIAN/ && tar czf ../../control.tar.gz * && cd ../..
$ fakeroot ar r hello_1.1-1_amd64.deb  debian-binary control.tar.gz data.tar.gz
ar: creating hello_1.1-1_amd64.deb
----

NOTE: The package will fail most linter checks. Indeed, we ignored many of the best practices that higher-level commands ensure but we will still be able to install this package on our server.

The C function executed by the command `dpkg --build` is the link:https://github.com/guillemj/dpkg/blob/1.20.7/dpkg-deb/build.c#L552-L728[function `do_build` in `./dpkg-deb/build.c`. Here is a simplified version: footnote:simplified[TODO]

.dpkg-deb/build.c
[source, c]
----
int
do_build(const char *const *argv)
{
  struct compress_params control_compress_params;
  struct tar_pack_options tar_options;
  struct dpkg_error err;
  struct dpkg_ar *ar;
  const char *dir, *dest;
  char *ctrldir;
  char *debar;
  char *tfbuf;
  int gzfd;

  /* Decode our arguments. */
  dir = *argv++;
  dest = *argv++;

  debar = gen_dest_pathname(dir, dest); // <1>
  ctrldir = str_fmt("%s/%s", dir, "DEBIAN");

  /* Now that we have verified everything it is time to actually
   * build something. Let's start by making the ar-wrapper. */
  ar = dpkg_ar_create(debar, 0644); // <2>

  /* Create a temporary file to store the control data in. */
  tfbuf = path_make_temp_template("dpkg-deb");
  gzfd = mkstemp(tfbuf);
  free(tfbuf);

  /* Select the compressor to use for our control archive. */
  control_compress_params.type = COMPRESSOR_TYPE_GZIP;
  control_compress_params.strategy = COMPRESSOR_STRATEGY_NONE;
  control_compress_params.level = -1;

  /* Fork a tar to package the control-section of the package. */
  tar_options.mode = "u+rw,go=rX";
  tar_options.root_owner_group = true;
  tarball_pack(ctrldir, control_treewalk_feed, &tar_options,
               &control_compress_params, gzfd);

  free(ctrldir);

  /* We have our first file for the ar-archive. Write a header for it
   * to the package and insert it. */
  const char deb_magic[] = "2.0\n";
  char adminmember[16 + 1];

  sprintf(adminmember, "%s%s", "control.tar",
          compressor_get_extension(control_compress_params.type));

  dpkg_ar_put_magic(ar); // <3>
  dpkg_ar_member_put_mem(ar, "debian-binary", deb_magic, strlen(deb_magic)); // <4>
  dpkg_ar_member_put_file(ar, adminmember, gzfd, -1); // <5>

  close(gzfd);

  /* Control is done, now we need to archive the data. */

  /* Start by creating a new temporary file. */
  tfbuf = path_make_temp_template("dpkg-deb");
  gzfd = mkstemp(tfbuf);
  free(tfbuf);

  /* Pack the directory into a tarball, feeding files from the callback. */
  tar_options.mode = NULL;
  tar_options.root_owner_group = opt_root_owner_group;
  tarball_pack(dir, file_treewalk_feed, &tar_options, &compress_params, gzfd);

  /* Okay, we have data.tar as well now, add it to the ar wrapper. */
  char datamember[16 + 1];

  sprintf(datamember, "%s%s", "data.tar",
          compressor_get_extension(compress_params.type));

  dpkg_ar_member_put_file(ar, datamember, gzfd, -1); // <6>

  close(gzfd);

  if (fsync(ar->fd))
    ohshite(_("unable to sync file '%s'"), ar->name);

  dpkg_ar_close(ar); // <7>

  free(debar);

  return 0;
}
----
<1> The variable `dir` is the local directory containing the package files to build. The variable `dest` is the optional filename for the final package file and `debar` is the final name as determined by the function `gen_dest_pathname`, which determines a default name if the argument is missing.
<2> The function `dpkg_ar_create` creates the archive file named after the variable `debar`.
<3> The function `dpkg_ar_put_magic` defines the magic number `!<arch>\n` telling Linux the file is of type `ar`.
<4> The function `dpkg_ar_member_put_mem` appends the file `debian-binary` with the content of the variable `deb_magic`.
<5> The function `dpkg_ar_member_put_file` appends the file `control.tar` with the content of a temporary file.
<6> Same as above for `data.tar`
<7> The function `dpkg_ar_close` is part of the housecleaning logic and simply closes the file descriptor.

Here is a simplified and minimalist rewrite of the code in Go.footnote:simplified[] The full code is available on GitHub in the repository link:https://github.com/julien-sobczak/linux-packages-from-scratch[julien-sobczak/linux-packages-from-scratch].

[source,go]
.cmd/dpkg/main.go
----
include::dpkg_build.go[]
----


To run the code:

[source, sh]
----
$ go run cmd/dpkg/main.go hello hello.deb
----

To inspect the newly Debian archive `hello.deb`, we can use the command `dpkg -c` to view the data files or use the command `ar` to view the real content of the archive:

[source, sh]
----
vagrant# dpkg -c /vagrant/hello.deb
-rw-r-x--- 0/0         2034781 1970-01-01 00:00 usr/bin/hello

vagrant#ar -tf /vagrant/hello.deb
ar -tf /vagrant/hello.deb
debian-binary
control.tar
data.tar
vagrant# ar -xf /vagrant/hello.deb data.tar
vagrant# tar -tf data.tar
usr/bin/hello
----

This completes the first part of this article. We created a Debian package from scratch! Now, we will have a look at the installation process.


