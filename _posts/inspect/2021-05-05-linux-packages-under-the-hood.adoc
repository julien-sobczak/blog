---
layout: post-inspect
title: "Linux Packages Under The Hood"
subtitle: "What happens when you install a Debian package on your machine?"
author: Julien Sobczak
date: '2021-05-05'
category: inspect
subject: Linux Packages
toc: true
---

:page-liquid:


[NOTE]
.What You Will Learn
====
* How to create an archive manually?
** How to create a package to install a Go binary using the `dpkg` command?
** What is the format of the archive? How to check its content?
** How to create the same package using standard Unix tools?
** *Case study*: How to create the same package in Golang?
* What happens when you install a package using `dpkg`?
** What contains the database?
** How files are copied to the host?
** What changed in the database?
** How to check that the package has been installed?
** *Case study*: How to install a package like `dpkg` in Golang?
* What happens when you install a package using `apt`?
** How does the command `apt` know where to search for packages?
** How to publish a package? What does the command `apt update`?
** How `apt` uses `dpkg` under the hood?
** *Case study*: How to install a package like `apt` in Golang?
====

[.lead]
A Linux package is a bundle to install a library or an application to a Linux system. It means new files on your filesystem and therefore a Linux package contains essentially the files that make the application (binary, configuration, doc, source) and a bunch of scripts to take additional actions.

[.lead]
I assume you have already installed many Linux packages and are used to work in a Linux environment. In this post, we will look under the hood and understand what really happens on your system when you run the different commands to install a package.

include::./2021-05-05-linux-packages-under-the-hood/part-1.adoc[]
include::./2021-05-05-linux-packages-under-the-hood/part-2.adoc[]
include::./2021-05-05-linux-packages-under-the-hood/part-3.adoc[]


== A Final Word

Linux packages are simple archives containing files to extract into another systems. The problem is trivial but the evil always comes from details.

In this article, we have glimpsed at some the challenges that a package manager must address. Packages build on top of others which means the manager must face one of the most difficult problems in computing, link:https://en.wikipedia.org/wiki/Dependency_hell[dependency management] (this is probably the second most harder problem behind naming variables). Despite that, Dpkg and APT are still approachable programs in that writing a basic version from scratch was not a daunting task. The biggest obstacle is that the commands `dpkg` and `apt` are interactive and such try do too much to avoid to rely on the user to fix problems, which explain why the sum of the two programs represents approximatively 100,000 lines of C and C++ code.

If you are managing a large pool of servers like a datacenter, reimplementing your own package manager can be interesting. For example, you could centralize all local databases to ensure that all machines share the same state, or you can take corrective actions like excluding a server from the pool when an upgrade ends in a bad state. Google provides a great example of application. They decided to implement their own package management system. “Any package change is guaranteed to succeed, or the machine is rolled back completely to the previous state. If the rollback fails, the machine is sent through our repairs process for reinstallation and potential hardware replacement. This approach allows us to eliminate much of the complexity of the package states.”footnote:[Building Secure and Reliable Systems, O'Reilly, Chapter 9 - Design for Recovery, Footnote 18]. The decision was surely not obvious, but the benefits are now obvious.

Implementing a package manager from scratch can be intimidating, but as we have seen in this article, the difficulty is not so great, especially if we consider the long list of features that APT supports that are not useful when managing a large number of homogenous machines in an automated way.



