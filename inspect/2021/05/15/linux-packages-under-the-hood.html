<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="author" content="Julien Sobczak">
<meta name="robots" content="index,follow,noodp">
<meta name="googlebot" content="index,follow">
<meta name="subject" content="Programming">


    <title>Linux Packages Under The Hood</title>

    <!-- To make search engines use the HTTPS url -->
<link rel="canonical" href="https://www.juliensobczak.com/inspect/2021/05/15/linux-packages-under-the-hood.html">
<link rel="alternate" type="application/atom+xml" title="I'm Lovin' I.T. - Julien Sobczak" href="https://www.juliensobczak.com/feed.xml">

<!-- Asciidoctor assets -->
<link href="/css/coderay.css" rel="stylesheet" />

<!-- Theme CSS -->
<link href="/css/app.css" rel="stylesheet">

<!-- Custom Fonts -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i,800,800i|Oswald" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Nothing+You+Could+Do" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Righteous" rel="stylesheet">

<!-- Favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">

</head>

<body id="page-post">
  <!-- Custom loader -->
<div id="loader-wrapper">
  <div id="loader"></div>
</div>


  <!-- Navigation -->

  <nav id="mainNav" class="navbar-default">

    
    
    <div id="reading-bar"></div>
    
    

    <div class="container">
      <a class="navbar-brand" href="/index.html">I'm lovin' I.T.</a>
      <div class="navbar-collabsible">
        <input id="collapsible" class="navbar-checkbox-toggle" type="checkbox">
        <label for="collapsible" class="navbar-label-toggle">Menu <i class="fas fa-bars"></i></label>
        <div class="navbar-collapse">
          <ul>

            
            <li>
            
                <a href="/categories/read.html">I'm readin' I.T.</a>
            </li>

            
            <li>
            
                <a href="/categories/write.html">I'm writin' I.T.</a>
            </li>

            
            <li class="active">
            
                <a href="/categories/inspect.html">I'm inspectin' I.T.</a>
            </li>

            <li class="page-scroll">
                <a href="https://fr.linkedin.com/in/julien-sobczak-56780a91">About Me</a>
            </li>
          </ul>
        </div>
      </div>
      <button id="zen-mode-in"><i class="fas fa-minus"></i></button>
      <button id="zen-mode-out"><i class="fas fa-plus"></i></button>
    </div>
  </nav>


  <header class="post-title post-inspect">
  <!-- see https://www.elastic.co/blog/elasticsearch-5-0-0-released -->
  <div class="container">

    <div class="icon-category">
    </div>

    <div class="metadata">
      <span class="date">May 15, 2021</span>

      

      

      <ul class="language">
        <li class="current-language"><a class="active" href="#">EN</a></li>
      </ul>

      <h2>Linux Packages Under The Hood</h2>
      
      <h3>What happens when you install a Debian package on your machine</h3>
      

      <p class="author-name">
        
        <span>By </span>
        
        <a href="/#about-me">Julien Sobczak</a>
      </p>

     </div>
    </div>
  </div>
</header>

<section class="content">

  <div class="container">

    <article>

      <div class="content">
      <div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Will Learn</div>
<div class="ulist">
<ul>
<li>
<p>How to create an archive manually.</p>
<div class="ulist">
<ul>
<li>
<p>How to create a simple package to install a Go binary using the <code>dpkg</code> command.</p>
</li>
<li>
<p>What is the format of the archive. How to check its content.</p>
</li>
<li>
<p>How to create the same package using standard Unix tools.</p>
</li>
<li>
<p><strong>Case study</strong>: How to create a package in Go.</p>
</li>
</ul>
</div>
</li>
<li>
<p>What happens when you install a package using <code>dpkg</code>.</p>
<div class="ulist">
<ul>
<li>
<p>What contains the database.</p>
</li>
<li>
<p>How files are copied to the host.</p>
</li>
<li>
<p>What changed in the database.</p>
</li>
<li>
<p>How to check that the package has been installed.</p>
</li>
<li>
<p><strong>Case study</strong>: How to install a package like <code>dpkg</code> in Go.</p>
</li>
</ul>
</div>
</li>
<li>
<p>What happens when you install a package using <code>apt</code>.</p>
<div class="ulist">
<ul>
<li>
<p>How does the command <code>apt</code> know where to search for packages.</p>
</li>
<li>
<p>What is the format of a repository.</p>
</li>
<li>
<p>What does the command <code>apt update</code>.</p>
</li>
<li>
<p>How <code>apt</code> uses <code>dpkg</code> under the hood.</p>
</li>
<li>
<p><strong>Case study</strong>: How to install a package like <code>apt</code> in Go.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph lead">
<p>A Linux package is a bundle of files that your package manager knows how to unpack on your system. Installing packages is something you are doing regularly and I suggest that we are looking under the hood to understand the steps between the creation and the installation of a Linux package.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Prerequisites</div>
<div class="paragraph">
<p>I assume you have already installed many Linux packages. A basic comprehension of the languages C and C++ is required and being familiar with the Go language will be helpful to follow the case studies.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect1">
<h2 id="table_of_contents">Table of Contents</h2>
<div class="sectionbody">
<div class="ulist compact">
<ul>
<li>
<p><a href="#sect-part1">How to create an archive manually</a>.</p>
<div class="ulist">
<ul>
<li>
<p>What you need to know about <a href="#wynk-debian-package-format">the Debian package format</a>, <a href="#wynk-dpkg">the <code>dpkg</code> command</a>, <a href="#wynk-deb822">the DEB822 format</a>.</p>
</li>
<li>
<p>The command <a href="#cmd-dpkg-build"><code>dpkg --build</code></a>.</p>
</li>
<li>
<p><a href="#sect-part1-go">The implementation in Go</a>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#sect-part2">What happens when you install a package using <code>dpkg</code></a>.</p>
<div class="ulist">
<ul>
<li>
<p>What you need to know about <a href="#wynk-conffiles">conffiles</a>, <a href="#wynk-dpkg-database">the Dpkg database</a>.</p>
</li>
<li>
<p>The command <a href="#cmd-dpkg-i"><code>dpkg -i</code></a>.</p>
</li>
<li>
<p><a href="#sect-part2-go">The implementation in Go</a>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#sect-part3">What happens when you install a package using <code>dpkg</code></a>.</p>
<div class="ulist">
<ul>
<li>
<p>What you need to know about <a href="#wynk-apt-get-aptitude"><code>apt</code>, <code>apt-get</code>, <code>aptitude</code></a>, <a href="#wynk-apt-configuration-files">configuration files</a>, <a href="#wynk-apt-configuration-options">configuration options</a>, <a href="#wynk-source-lists">source lists</a>, <a href="#wynk-repositories">repositories</a>, <a href="#wynk-apt-diffs">diffs</a>, <a href="#wynk-dir-apt-cache"><code>/var/cache/apt/</code></a>, <a href="#wynk-dir-apt-lib"><code>/var/lib/apt/</code></a>, <a href="#wynk-apt-cache-files">cache files</a>.</p>
</li>
<li>
<p>The commands <a href="#cmd-apt-update"><code>apt update</code></a>, <a href="#cmd-apt-list"><code>apt list</code></a>, and <a href="#cmd-apt-install"><code>apt install</code></a>.</p>
</li>
<li>
<p><a href="#sect-part3-go">The implementation in Go</a>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">This post is long, really long.</div>
<div class="paragraph">
<p>The repositories <code>dpkg</code> and <code>apt</code> contain more than 100,000 lines of code.</p>
</div>
<div class="paragraph">
<p><strong>When trying to explain how code works, there is a though balance to find between showing the code untouched, and simplifying it at the risk of denaturing it.</strong> In this post, I decide to use both approaches. I present the original code slightly annotated, removing only debug messages and the support of command flags not covered in this article. I also present a minimal rewrite of these programs in Go richly commented. Overall, that represents a lot of code, but as developers, we are used to skim over large codebase, and I hope you will find your way.</p>
</div>
<div class="paragraph">
<p>In addition, there are many asides to explain some Dpkg and Apt features that you can safely skip if you are already familiar with the tools.</p>
</div>
<div class="paragraph">
<p>Please remember that if you find the post too long to read, just imagine how long it was to write it üòÅ. <strong>Happy reading!</strong></p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sect-part1">How to create a package manually</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Linux packages are commonly available in a <code>.deb</code> and a <code>.rpm</code> file.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>.deb</code> files are meant for distributions of Linux that derive from Debian (Ubuntu, Linux Mint, etc.).</p>
</li>
<li>
<p>The <code>.rpm</code> files are used primarily by distributions that derive from Redhat based distros (Fedora, CentOS, RHEL).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Why two formats?</div>
<div class="paragraph">
<p>Because there are two main Linux distributions: Red Hat and Debian and each one has its own file formats: <code>.rpm</code> for Red Hat Package Manager and <code>.deb</code> for Debian.</p>
</div>
<div class="paragraph">
<p>Both package formats have a lot in common and we will only discuss Debian packages in this document. The following table summarizes the main differences between the archive files.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-center valign-top">.rpm</th>
<th class="tableblock halign-center valign-top">.deb</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Archive Format</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Uses the <a href="https://en.wikipedia.org/wiki/Cpio"><code>cpio</code> command and file format</a>.</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Uses the <a href="https://en.wikipedia.org/wiki/Ar_(Unix)"><code>ar</code> command and file format</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Package Manager</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>rpm</code><br>
(1997, Written in C)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>dpkg</code><br>
(1993, Written in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Frontend Package Manager</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>yum</code><br>
(2011, Written in Python)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>apt</code><br>
(1999, Written in C++)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Database</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>/var/lib/rpm</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>/var/lib/dpkg</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Database Format</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Berkeley DB files</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">DEB 822 flat files</p></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A package is a collection of files to distribute applications or libraries via the Debian package management system. The aim of packaging is to allow the automation of installing, upgrading, configuring, and removing computer programs in a consistent manner.</p>
</div>
<div id="wynk-debian-package-format" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About the Debian Package Format</div>
<div class="paragraph">
<p>A <code>.deb</code> file is an <code>ar</code> archive. The <code>ar</code> command is an ancestor of the common <code>tar</code> command and was already present in the first Unix version in 1971! Now, this command is (mostly) only used by Debian packages. This archive contains 3 files:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>debian-binary</code>: A text file containing <code>2.0\n</code>. This states the version of the deb file format. For 2.0, all other lines get ignored.</p>
</li>
<li>
<p><code>data.tar.gz</code>: A <code>tar</code> archive containing all files that will be installed with their destination paths</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>./
./sbin/
./sbin/parted
./usr/
./usr/share/
./usr/share/man/
./usr/share/man/man8/
./usr/share/man/man8/parted.8.gz
./usr/share/doc/
./usr/share/doc/parted/
./usr/share/doc/parted/README.Debian
./usr/share/doc/parted/copyright
./usr/share/doc/parted/changelog.Debian.gz
./usr/share/doc/parted/changelog.gz</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>control.tar.gz</code>: A <code>tar</code> archive containing various files useful for the <code>dpkg</code> command to do its job: metadata about the package (<code>control</code>) including the list of required dependencies, the md5 sums of every data file to check integrity (<code>md5sums</code>), and also maintainer scripts (ex: <code>postinst</code> for post-installation, <code>prerm</code> for pre-removal, etc.), which are executables that must be run when installing or removing a package.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>control
md5sums
postinst
prerm</pre>
</div>
</div>
<div class="paragraph">
<p><em>Further documentation</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://raphaelhertzog.com/2010/11/08/5-reasons-why-a-debian-package-is-more-than-a-simple-file-archive/">5 reasons why a Debian package is more than a simple file archive, Rapha√´l Hertzog</a></p>
</li>
<li>
<p><a href="https://www.debian.org/doc/manuals/maint-guide/">Debian New Maintainers' Guide</a>, the official procedure to create a package the "Debian way".</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also learn more about Debian packages by installing a Debian package üòÄ (the PDF is also available <a href="https://www.debian.org/doc/manuals/packaging-tutorial/packaging-tutorial.en.pdf">online</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ apt install packaging-tutorial
# Check /usr/share/doc/packaging-tutorial/packaging-tutorial.pdf</code></pre>
</div>
</div>
<div id="wynk-dpkg" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About the Command <code>dpkg</code></div>
<div class="paragraph">
<p>The project Dpkg started in 1994, at the same time the Debian package format was created, and thus the command <code>dpkg</code> works only with <code>.deb</code> binary archives. You must provide the archive as the command does not know how to retrieve it by itself. The command manages a database stored under <code>/var/lib/dpkg</code> to keep note of everything that is installed on the server, which is essential to determine what to clean when you remove a package.</p>
</div>
<div class="paragraph">
<p>Note that the command <code>dpkg --build</code> redirects to the command <code>dpkg-deb --build</code> and the command <code>dpkg --list</code> redirects to the command <code>dpkg-query --list</code>. The code of these commands is present in the same repository in <code>./dpkg-deb/</code> and <code>./src/querycmd.c</code> respectively.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Official Repository: <a href="https://git.dpkg.org/cgit/dpkg/dpkg.git" class="bare">https://git.dpkg.org/cgit/dpkg/dpkg.git</a></p>
</li>
<li>
<p>GitHub Mirror: <a href="https://github.com/guillemj/dpkg" class="bare">https://github.com/guillemj/dpkg</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To illustrate this post, we will use the Hello World example present in the <a href="https://gobyexample.com/hello-world">Go by example tutorial</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ cat &gt; hello.go &lt;&lt; HERE
package main
import &quot;fmt&quot;
func main() {
    fmt.Println(&quot;hello world&quot;)
}
HERE
$ go run hello.go
hello world
$ env GOOS=linux GOARCH=amd64 go build hello.go # Make sure to build for Linux
$ ls
hello    hello.go
$ chmod +x hello
$ ./hello
hello world</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our goal is to package this binary and the most popular solution to build a Debian package for a Go program is the <a href="https://go-team.pages.debian.net/packaging.html">utility <code>dh-golang</code></a>. As we want to use the most basic commands to get as close as possible to the process, we will use the standard <code>dpkg</code> command even if that means not building a world-class Debian package.</p>
</div>
<div class="sect2">
<h3 id="prerequisites">Prerequisites</h3>
<div class="paragraph">
<p>To test the packages we are going to build and install, we will use a Debian VM in order to keep your system safe. We will use <a href="https://www.vagrantup.com/">Vagrant</a> to create this server. Make sure Vagrant is installed on your system by following the <a href="https://learn.hashicorp.com/tutorials/vagrant/getting-started-install?in=vagrant/getting-started">installation procedure</a> for your operating system.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a companion GitHub repository <a href="https://github.com/julien-sobczak/linux-packages-under-the-hood">julien-sobczak/linux-packages-under-the-hood</a> to this blog post. This repository is optional for this article. It mostly contains a <code>Vagrantfile</code> to start the virtual machine, the files to create various Debian versions of the package <code>hello</code>, and also the Go code that reimplements minimal versions of the <code>dpkg</code> and <code>apt</code> commands. You will find more information in the <a href="https://github.com/julien-sobczak/linux-packages-under-the-hood/blob/master/README.md"><code>README.md</code></a> file of this repository.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ mkdir sandbox
$ cd sandbox
$ vagrant init
$ echo &gt; Vagranfile &lt;&lt;EOF
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;debian/buster64&quot;
end
EOF
$ vagrant up
# wait a few minutes
$ vagrant ssh
vagrant$ uname -a
Linux buster 4.19.0-16-amd64 #1 SMP Debian 4.19.181-1 (2021-03-19) x86_64 GNU/Linux</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using Vagrant, the directory containing your <code>Vagrantfile</code> is accessible from the virtual machine from the directory <code>/vagrant</code>. We will use it to copy our <code>hello</code> binary program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ ls
Vagrantfile
$ cp /path/to/hello .
$ vagrant ssh
vagrant$ cd /vagrant
vagrant$ ls
hello Vagrantfile</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All commands whose prompt starts with <code>vagrant#</code> must be run inside the virtual machine. Otherwise, run the commands from your host.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We are ready to create a Debian package for our Hello program.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# cd /vagrant/
vagrant# mkdir -p ./debian/usr/bin <i class="conum" data-value="1"></i><b>(1)</b>
vagrant# cp hello ./debian/usr/bin/
vagrant# mkdir -p ./debian/DEBIAN <i class="conum" data-value="1"></i><b>(1)</b>
vagrant# cat &gt; ./debian/DEBIAN/control &lt;&lt;EOF
Package: hello
Version: 1.1-1
Section: base
Priority: optional
Architecture: amd64
Maintainer: Julien Sobczak
Description: Say Hello
EOF
vagrant# cat &gt; ./debian/DEBIAN/preinst &lt;&lt;EOF <i class="conum" data-value="2"></i><b>(2)</b>
#!/bin/sh
echo &quot;preinst says hello&quot;;
EOF
vagrant# cat &gt; ./debian/DEBIAN/postinst &lt;&lt;EOF <i class="conum" data-value="2"></i><b>(2)</b>
#!/bin/sh
echo &quot;postinst says hello&quot;;
EOF
vagrant# tree /vagrant/debian/
|-- DEBIAN
|   |-- control
|   |-- preinst
|   `-- postinst
`-- usr
    `-- bin
        `-- hello</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The first version of our package <code>hello</code> contains only the binary <code>hello</code> built previously and a DEB822 file <code>control</code> with the package metadata.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We also append basic maintainer scripts that displays a message in the console so that we will know when the installation process runs them.</td>
</tr>
</table>
</div>
<div id="wynk-deb822" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About the DEB822 Format</div>
<div class="paragraph">
<p>This format can be seen as an ancestor of YAML or JSON. Here is an example showing the three supported types of fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="deb822">FieldSimple: simple value
FieldFolded: very long value
 continuing on the next line starting with a space.
FieldMultiline:
 /usr/bin/cmd1
 /usr/bin/cmd2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The format is used by the file <code>control</code> but also by some files in the <code>dpkg</code> database such as <code>/var/lib/dpkg/status</code>. This format is also used by the command <code>apt</code>, which will be covered later.</p>
</div>
<div class="paragraph">
<p><em>Further documentation</em>: Check the <a href="https://man7.org/linux/man-pages/man5/deb822.5.html">man page</a> for additional information.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="cmd-dpkg-build"><code>dpkg --build</code></h3>
<div class="paragraph">
<p>We will use the command <code>dpkg --build</code> to build our package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ apt install fakeroot # install the fakeroot command
$ fakeroot dpkg --build debian hello_1.1-1_amd64.deb <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This command builds a Debian package, which as outlined before, consists in building an <code>ar</code> archive containing two <code>tar</code> archives: the content of our directory <code>DEBIAN/</code> in <code>control.tar.gz</code> and the other files in <code>data.tar.gz</code>. We use the <code>fakeroot</code> command to make sure files inside the archive are created with the user <code>root</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can also reproduce its working <a href="https://unix.stackexchange.com/questions/30303/how-to-create-a-deb-file-manually">using standard Bash commands</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ apt install binutils # install the ar command
$ apt install fakeroot # install the fakeroot command
$ echo 2.0 &gt; debian-binary
$ cd debian &amp;&amp; tar czf ../data.tar.gz [a-z]* &amp;&amp; cd ..
$ cd debian/DEBIAN/ &amp;&amp; tar czf ../../control.tar.gz * &amp;&amp; cd ../..
$ fakeroot ar r hello_1.1-1_amd64.deb debian-binary control.tar.gz data.tar.gz
ar: creating hello_1.1-1_amd64.deb <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The package will fail most linter checks. Indeed, we ignored many of the best practices that higher-level commands ensure but we will still be able to install this package on our server.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now is the time to look at the code. Dpkg is written in C, and the function executed by the command <code>dpkg --build</code> is the <a href="https://github.com/guillemj/dpkg/blob/1.20.7/dpkg-deb/build.c#L552-L728">function <code>do_build</code> in <code>./dpkg-deb/build.c</code></a>.</p>
</div>
<div class="listingblock">
<div class="title">dpkg-deb/build.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="predefined-type">int</span>
do_build(<span class="directive">const</span> <span class="predefined-type">char</span> *<span class="directive">const</span> *argv)
{
  <span class="keyword">struct</span> compress_params control_compress_params;
  <span class="keyword">struct</span> tar_pack_options tar_options;
  <span class="keyword">struct</span> dpkg_error err;
  <span class="keyword">struct</span> dpkg_ar *ar;
  <span class="directive">const</span> <span class="predefined-type">char</span> *dir, *dest;
  <span class="predefined-type">char</span> *ctrldir;
  <span class="predefined-type">char</span> *debar;
  <span class="predefined-type">char</span> *tfbuf;
  <span class="predefined-type">int</span> gzfd;

  <span class="comment">/* Decode our arguments. */</span>
  dir = *argv++;
  dest = *argv++;

  debar = gen_dest_pathname(dir, dest); <i class="conum" data-value="1"></i><b>(1)</b>
  ctrldir = str_fmt(<span class="string"><span class="delimiter">&quot;</span><span class="content">%s/%s</span><span class="delimiter">&quot;</span></span>, dir, <span class="string"><span class="delimiter">&quot;</span><span class="content">DEBIAN</span><span class="delimiter">&quot;</span></span>);

  <span class="comment">/* Now that we have verified everything it is time to actually
   * build something. Let's start by making the ar-wrapper. */</span>
  ar = dpkg_ar_create(debar, <span class="octal">0644</span>); <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="comment">/* Create a temporary file to store the control data in. */</span>
  tfbuf = path_make_temp_template(<span class="string"><span class="delimiter">&quot;</span><span class="content">dpkg-deb</span><span class="delimiter">&quot;</span></span>);
  gzfd = mkstemp(tfbuf);
  free(tfbuf);

  <span class="comment">/* Select the compressor to use for our control archive. */</span>
  control_compress_params.type = COMPRESSOR_TYPE_GZIP;
  control_compress_params.strategy = COMPRESSOR_STRATEGY_NONE;
  control_compress_params.level = -<span class="integer">1</span>;

  <span class="comment">/* Fork a tar to package the control-section of the package. */</span>
  tar_options.mode = <span class="string"><span class="delimiter">&quot;</span><span class="content">u+rw,go=rX</span><span class="delimiter">&quot;</span></span>;
  tar_options.root_owner_group = <span class="predefined-constant">true</span>;
  tarball_pack(ctrldir, control_treewalk_feed, &amp;tar_options,
               &amp;control_compress_params, gzfd);

  free(ctrldir);

  <span class="comment">/* We have our first file for the ar-archive. Write a header for it
   * to the package and insert it. */</span>
  <span class="directive">const</span> <span class="predefined-type">char</span> deb_magic[] = <span class="string"><span class="delimiter">&quot;</span><span class="content">2.0</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
  <span class="predefined-type">char</span> adminmember[<span class="integer">16</span> + <span class="integer">1</span>];

  sprintf(adminmember, <span class="string"><span class="delimiter">&quot;</span><span class="content">%s%s</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">control.tar</span><span class="delimiter">&quot;</span></span>,
          compressor_get_extension(control_compress_params.type));

  dpkg_ar_put_magic(ar); <i class="conum" data-value="3"></i><b>(3)</b>
  dpkg_ar_member_put_mem(ar, <span class="string"><span class="delimiter">&quot;</span><span class="content">debian-binary</span><span class="delimiter">&quot;</span></span>, deb_magic, strlen(deb_magic)); <i class="conum" data-value="4"></i><b>(4)</b>
  dpkg_ar_member_put_file(ar, adminmember, gzfd, -<span class="integer">1</span>); <i class="conum" data-value="5"></i><b>(5)</b>

  close(gzfd);

  <span class="comment">/* Control is done, now we need to archive the data. */</span>

  <span class="comment">/* Start by creating a new temporary file. */</span>
  tfbuf = path_make_temp_template(<span class="string"><span class="delimiter">&quot;</span><span class="content">dpkg-deb</span><span class="delimiter">&quot;</span></span>);
  gzfd = mkstemp(tfbuf);
  free(tfbuf);

  <span class="comment">/* Pack the directory into a tarball, feeding files from the callback. */</span>
  tar_options.mode = <span class="predefined-constant">NULL</span>;
  tar_options.root_owner_group = opt_root_owner_group;
  tarball_pack(dir, file_treewalk_feed, &amp;tar_options, &amp;compress_params, gzfd);

  <span class="comment">/* Okay, we have data.tar as well now, add it to the ar wrapper. */</span>
  <span class="predefined-type">char</span> datamember[<span class="integer">16</span> + <span class="integer">1</span>];

  sprintf(datamember, <span class="string"><span class="delimiter">&quot;</span><span class="content">%s%s</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">data.tar</span><span class="delimiter">&quot;</span></span>,
          compressor_get_extension(compress_params.type));

  dpkg_ar_member_put_file(ar, datamember, gzfd, -<span class="integer">1</span>); <i class="conum" data-value="6"></i><b>(6)</b>

  close(gzfd);

  <span class="keyword">if</span> (fsync(ar-&gt;fd))
    ohshite(_(<span class="string"><span class="delimiter">&quot;</span><span class="content">unable to sync file '%s'</span><span class="delimiter">&quot;</span></span>), ar-&gt;name);

  dpkg_ar_close(ar); <i class="conum" data-value="7"></i><b>(7)</b>

  free(debar);

  <span class="keyword">return</span> <span class="integer">0</span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The variable <code>dir</code> is the local directory containing the package files to build. The variable <code>dest</code> is the optional filename for the final package file and <code>debar</code> is the final name as determined by the function <code>gen_dest_pathname</code>, which determines a default name if the argument is missing.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The function <code>dpkg_ar_create</code> creates the archive file named after the variable <code>debar</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The function <code>dpkg_ar_put_magic</code> defines the magic number <code>!&lt;arch&gt;\n</code> telling Linux the file is of type <code>ar</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The function <code>dpkg_ar_member_put_mem</code> appends the file <code>debian-binary</code> with the content of the variable <code>deb_magic</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The function <code>dpkg_ar_member_put_file</code> appends the file <code>control.tar</code> with the content of a temporary file.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Same as above for <code>data.tar</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The function <code>dpkg_ar_close</code> is part of the housecleaning logic and simply closes the file descriptor.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="sect-part1-go">Case Study</h3>
<div class="paragraph">
<p>What follows is a minimal rewrite of this code in Go. The full code is available on GitHub in the repository <a href="https://github.com/julien-sobczak/linux-packages-under-the-hood">julien-sobczak/linux-packages-under-the-hood</a>.</p>
</div>
<div class="listingblock">
<div class="title">cmd/dpkg/main.go</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="go"><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string"><span class="delimiter">&quot;</span><span class="content">archive/tar</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">bytes</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">fmt</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">io/ioutil</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">log</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">os</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">path/filepath</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">strings</span><span class="delimiter">&quot;</span></span>

    <span class="string"><span class="delimiter">&quot;</span><span class="content">github.com/blakesmith/ar</span><span class="delimiter">&quot;</span></span>
)

<span class="keyword">func</span> main() {
    <span class="comment">// This program expects two arguments:</span>
    <span class="comment">// - The directory following the resources to package in the archive.</span>
    <span class="comment">// - The name of the output .deb file</span>
    <span class="keyword">if</span> <span class="predefined">len</span>(os.Args) &lt; <span class="integer">3</span> {
        log.Fatalf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Missing 'directory' and/or 'dest' arguments.</span><span class="delimiter">&quot;</span></span>)
    }

    directory := os.Args[<span class="integer">1</span>]
    dest := os.Args[<span class="integer">2</span>]

    <span class="comment">// Create the Debian archive file</span>
    fdeb, _ := os.Create(dest)
    <span class="keyword">defer</span> fdeb.Close()

    <span class="comment">// A Debian package is an archive using the AR format.</span>
    <span class="comment">// We use an external Go module to create the archive</span>
    <span class="comment">// as the standard library does not support it but supports</span>
    <span class="comment">// the tar format that will be used for the control and data files.</span>

    writer := ar.NewWriter(fdeb)
    writer.WriteGlobalHeader()

    <span class="comment">// A Debian package contains 3 files that must be</span>
    <span class="comment">// added in a precise order.</span>
    <span class="comment">// We use two utility functions that will be defined later:</span>
    <span class="comment">// - arPutFile is a wrapper around the library to add an entry.</span>
    <span class="comment">// - tarballPack creates a tarball using the Go library.</span>

    <span class="comment">// Append debian-binary</span>
    arPutFile(writer, <span class="string"><span class="delimiter">&quot;</span><span class="content">debian-binary</span><span class="delimiter">&quot;</span></span>, []<span class="predefined-type">byte</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">2.0</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>))

    <span class="comment">// Append control.tar</span>
    controlDir := filepath.Join(directory, <span class="string"><span class="delimiter">&quot;</span><span class="content">DEBIAN</span><span class="delimiter">&quot;</span></span>)
    controlTarball := tarballPack(controlDir, <span class="predefined-constant">nil</span>)
    arPutFile(writer, <span class="string"><span class="delimiter">&quot;</span><span class="content">control.tar</span><span class="delimiter">&quot;</span></span>, controlTarball)

    <span class="comment">// Append data.tar</span>
    dataDir := directory
    dataTarball := tarballPack(dataDir, <span class="keyword">func</span>(path <span class="predefined-type">string</span>) <span class="predefined-type">bool</span> {
        <span class="comment">// Filter DEBIAN/ files</span>
        <span class="keyword">return</span> strings.HasPrefix(path, controlDir)
    })
    arPutFile(writer, <span class="string"><span class="delimiter">&quot;</span><span class="content">data.tar</span><span class="delimiter">&quot;</span></span>, dataTarball)
}

<span class="comment">// arPutFile adds a new entry in a AR archive.</span>
<span class="keyword">func</span> arPutFile(w *ar.Writer, name <span class="predefined-type">string</span>, body []<span class="predefined-type">byte</span>) {
    hdr := &amp;ar.Header{
        Name: name,
        Mode: <span class="octal">0600</span>,
        Uid:  <span class="integer">0</span>,
        Gid:  <span class="integer">0</span>,
        Size: <span class="predefined-type">int64</span>(<span class="predefined">len</span>(body)),
    }
    w.WriteHeader(hdr)
    w.Write(body)
}

<span class="comment">// tarballPack traverses a local directory to add all files under it</span>
<span class="comment">// into a tarball.</span>
<span class="keyword">func</span> tarballPack(directory <span class="predefined-type">string</span>, filter <span class="keyword">func</span>(<span class="predefined-type">string</span>) <span class="predefined-type">bool</span>) []<span class="predefined-type">byte</span> {
    <span class="keyword">var</span> bufdata bytes.Buffer
    twdata := tar.NewWriter(&amp;bufdata)
    filepath.Walk(
        directory,
        <span class="keyword">func</span>(path <span class="predefined-type">string</span>, info os.FileInfo, errParent <span class="predefined-type">error</span>) <span class="predefined-type">error</span> {
            <span class="keyword">if</span> info.IsDir() {
                <span class="keyword">return</span> <span class="predefined-constant">nil</span>
            }
            <span class="keyword">if</span> filter != <span class="predefined-constant">nil</span> &amp;&amp; filter(path) {
                <span class="keyword">return</span> <span class="predefined-constant">nil</span>
            }
            sep := fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%c</span><span class="delimiter">&quot;</span></span>, filepath.Separator)
            name := strings.TrimPrefix(strings.TrimPrefix(path, directory), sep)
            hdr := &amp;tar.Header{
                Name: name,
                Uid:  <span class="integer">0</span>, <span class="comment">// root</span>
                Gid:  <span class="integer">0</span>, <span class="comment">// root</span>
                Mode: <span class="octal">0650</span>,
                Size: info.Size(),
            }
            twdata.WriteHeader(hdr)
            content, _ := ioutil.ReadFile(path)
            twdata.Write(content)

            <span class="keyword">return</span> <span class="predefined-constant">nil</span>
        })
    twdata.Close()

    <span class="keyword">return</span> bufdata.Bytes()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To run the code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ go run main.go hello hello.deb</code></pre>
</div>
</div>
<div class="paragraph">
<p>To inspect the resulting archive <code>hello.deb</code>, we can use the command <code>dpkg -c</code> to view the data files or use the command <code>ar</code> to view the real content of the archive:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# dpkg -c /vagrant/hello.deb
-rw-r-x--- 0/0         2034781 1970-01-01 00:00 usr/bin/hello

vagrant# ar -tf /vagrant/hello.deb
ar -tf /vagrant/hello.deb
debian-binary
control.tar
data.tar
vagrant# ar -xf /vagrant/hello.deb data.tar
vagrant# tar -tf data.tar
usr/bin/hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>üéâ <strong>We have finished with the format <code>.deb</code>.</strong> This completes the first part of this article. We created a Debian package from scratch! Now, we will inspect the installation process.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sect-part2">What happens when you install a package using <code>dpkg</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The command to install a Debian binary package file is <code>dpkg -i <em>myarchive.deb</em></code> and will be the subject of this second part.</p>
</div>
<div class="sect2">
<h3 id="cmd-dpkg-i"><code>dpkg -i</code></h3>
<div class="paragraph">
<p>Let&#8217;s run the command on our Debian archive:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# dpkg -i /vagrant/hello.deb
Selecting previously unselected package hello.
(Reading database ... 32264 files and directories currently installed.)
Preparing to unpack /vagrant/hello.deb ...
preinst says hello
Unpacking hello (1.1-1) ...
Setting up hello (1.1-1) ...
postinst says hello

vagrant# hello
hello world</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command does a lot of interesting things and the code is larger than the previous <code>build</code> command. The <a href="https://man7.org/linux/man-pages/man1/dpkg.1.html">man page</a> details the installation steps and we will present the main code for every one of them.</p>
</div>
<div class="paragraph">
<p>The entry point for the installation of a package is the function <code>archivefiles</code>, and most specifically the function <code>process_archive</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/archives.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="predefined-type">int</span>
archivefiles(<span class="directive">const</span> <span class="predefined-type">char</span> *<span class="directive">const</span> *argv)
{
  <span class="predefined-type">int</span> i;

  modstatdb_open(msdbrw_readonly);

  <span class="keyword">for</span> (i = <span class="integer">0</span>; argv[i]; i++) {
    process_archive(argv[i]); <i class="conum" data-value="1"></i><b>(1)</b>
  }

  process_queue(); <i class="conum" data-value="2"></i><b>(2)</b>

  trigproc_run_deferred();
  modstatdb_shutdown();

  <span class="keyword">return</span> <span class="integer">0</span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The main function iterates over all packages to install and delegates to the function <code>process_archive</code> for the unpacking.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The function <code>process_queue</code> configures all packages that have been unpacked in the previous step. We will explain the differences between these two steps.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s go!</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="1">
<li>
<p><strong>Extract the control files of the new package.</strong></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">src/unpack.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">void</span> process_archive(<span class="directive">const</span> <span class="predefined-type">char</span> *filename) {
  <span class="error">‚Ä¶</span>
  cidir = get_control_dir(cidir); <i class="conum" data-value="1"></i><b>(1)</b>
  pid = subproc_fork();
  <span class="keyword">if</span> (pid == <span class="integer">0</span>) {
    cidirrest[-<span class="integer">1</span>] = <span class="char">'\0'</span>;
    execlp(<span class="string"><span class="delimiter">&quot;</span><span class="content">dpkg-deb</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">dpkg-deb</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">--control</span><span class="delimiter">&quot;</span></span>, filename, cidir, <span class="predefined-constant">NULL</span>); <i class="conum" data-value="2"></i><b>(2)</b>
    ohshite(_(<span class="string"><span class="delimiter">&quot;</span><span class="content">unable to execute %s (%s)</span><span class="delimiter">&quot;</span></span>),
            _(<span class="string"><span class="delimiter">&quot;</span><span class="content">package control information extraction</span><span class="delimiter">&quot;</span></span>), BACKEND);
  }
  subproc_reap(pid, <span class="string"><span class="delimiter">&quot;</span><span class="content">dpkg-deb --control</span><span class="delimiter">&quot;</span></span>, <span class="integer">0</span>);
  <span class="error">‚Ä¶</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a temporary directory (commonly <code>/var/lib/dpkg/tmp.ci/</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Run the command <code>dpkg --control</code> to extract the <code>DEBIAN/</code> directory into it.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then, the code parses the <code>control</code> file to initialize the struct <code>pkginfo</code>, which is the main structure to represent a package. (You can check the const <code>fieldinfos</code> in <code>parse.c</code> to find the mapping between the file and the struct.) Here is a minimal version of this structure with the most important fields annotated:</p>
</div>
<div class="listingblock">
<div class="title">lib/dpkg/dpkg-db.h</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="comment">/**
 * Node describing an architecture package instance.
 *
 * This structure holds state information.
 */</span>
<span class="keyword">struct</span> pkginfo {
  <span class="keyword">struct</span> pkgset *set;

  <span class="keyword">enum</span> pkgwant want; <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="comment">/** The error flag bitmask. */</span>
  <span class="keyword">enum</span> pkgeflag eflag; <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="keyword">enum</span> pkgstatus status;
  <span class="keyword">enum</span> pkgpriority priority;

  <span class="keyword">struct</span> pkgbin installed; <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="keyword">struct</span> pkgbin available; <i class="conum" data-value="3"></i><b>(3)</b>

  <span class="keyword">struct</span> fsys_namenode_list *files; <i class="conum" data-value="4"></i><b>(4)</b>
  <span class="predefined-type">bool</span> files_list_valid; <i class="conum" data-value="4"></i><b>(4)</b>

  <span class="comment">/* The status has changed, it needs to be logged. */</span>
  <span class="predefined-type">bool</span> status_dirty; <i class="conum" data-value="5"></i><b>(5)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The enum <code>want</code> determines the expected action for this package, like <code>PKG_WANT_INSTALL</code> for installation, or <code>PKG_WANT_PURGE</code> for the removal of the package and its configuration files.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>eflag</code> is initialized if the parser finds an error in the control file (ex: missing field), and also later during the installation process.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>installed</code> and <code>available</code> fields contain most of the information present in the <code>control</code> files concerning a possible installed version of the package and the new version to install.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Some fields like <code>files</code> are initialized later by other functions like  <code>db-fsys-files.c#ensure_packagefiles_available</code>, which reads the file <code>/var/lib/dpkg/list/hello.list</code> to populate this field.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>status_dirty</code> flag is set when the current status of the package changes, for example from <code>PKG_STAT_UNPACKED</code> to <code>PKG_STAT_INSTALLED</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And now, the function responsible to create this struct:</p>
</div>
<div class="listingblock">
<div class="title">src/unpack.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">void</span> process_archive(<span class="directive">const</span> <span class="predefined-type">char</span> *filename) {
  <span class="keyword">struct</span> pkginfo *pkg;
  <span class="error">‚Ä¶</span>
  parsedb(cidir, parsedb_flags, &amp;pkg); <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="error">‚Ä¶</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>parsedb</code> simply reads a file in <a href="https://man7.org/linux/man-pages/man5/deb822.5.html">Debian RFC822 format</a>, the format we used to write the <code>control</code> file.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p><strong>If another version of the same package was installed before the new installation, execute <code>prerm</code> script of the old package.</strong></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">unpack.c#process_archive</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">void</span> process_archive(<span class="directive">const</span> <span class="predefined-type">char</span> *filename) {
  <span class="error">‚Ä¶</span>
  oldversionstatus = pkg-&gt;status; <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="keyword">if</span> (oldversionstatus == PKG_STAT_INSTALLED) {
    pkg_set_eflags(pkg, PKG_EFLAG_REINSTREQ);
    pkg_set_status(pkg, PKG_STAT_HALFCONFIGURED); <i class="conum" data-value="2"></i><b>(2)</b>
    modstatdb_note(pkg); <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="keyword">if</span> (dpkg_version_compare(&amp;pkg-&gt;available.version,
                             &amp;pkg-&gt;installed.version) &gt;= <span class="integer">0</span>)
      <span class="comment">/* Upgrade or reinstall. */</span>
      maintscript_fallback(pkg, PRERMFILE, <span class="string"><span class="delimiter">&quot;</span><span class="content">pre-removal</span><span class="delimiter">&quot;</span></span>, cidir, cidirrest,
                           <span class="string"><span class="delimiter">&quot;</span><span class="content">upgrade</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">failed-upgrade</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="keyword">else</span> <span class="comment">/* Downgrade =&gt; no fallback */</span>
      maintscript_installed(pkg, PRERMFILE, <span class="string"><span class="delimiter">&quot;</span><span class="content">pre-removal</span><span class="delimiter">&quot;</span></span>,
                            <span class="string"><span class="delimiter">&quot;</span><span class="content">upgrade</span><span class="delimiter">&quot;</span></span>,
                            versiondescribe(&amp;pkg-&gt;available.version,
                                            vdew_nonambig),
                            <span class="predefined-constant">NULL</span>); <i class="conum" data-value="2"></i><b>(2)</b>
    pkg_set_status(pkg, PKG_STAT_UNPACKED); <i class="conum" data-value="1"></i><b>(1)</b>
    oldversionstatus = PKG_STAT_UNPACKED;
    modstatdb_note(pkg); <i class="conum" data-value="1"></i><b>(1)</b>
  }
  <span class="error">‚Ä¶</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The status read during parsing is reused to determine if the package is already installed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Update the package status to keep trace that the package has been partially installed. The status will be changed several times during the installation. The function <code>modstatdb_note</code> persists the new state to disk.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>maintscript_fallback</code> and <code>maintscript_installed</code> delegates to <code>maintscript_exec</code> defined in the same file <code>src/script.c</code>. This function runs the script in a fork process and aborts if the return code is greater than 0. Differences between the various calls are explained in the next step.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p><strong>Run <code>preinst</code> script, if provided by the package.</strong></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">unpack.c#process_archive</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">void</span> process_archive(<span class="directive">const</span> <span class="predefined-type">char</span> *filename) {
  <span class="error">‚Ä¶</span>
  <span class="keyword">if</span> (pkg-&gt;status == PKG_STAT_NOTINSTALLED) {
    pkg-&gt;installed.version = pkg-&gt;available.version;
    pkg-&gt;installed.multiarch = pkg-&gt;available.multiarch;
  }
  pkg_set_status(pkg, PKG_STAT_HALFINSTALLED);
  modstatdb_note(pkg);
  <span class="keyword">if</span> (oldversionstatus == PKG_STAT_NOTINSTALLED) { <i class="conum" data-value="1"></i><b>(1)</b>
    maintscript_new(pkg, PREINSTFILE, <span class="string"><span class="delimiter">&quot;</span><span class="content">pre-installation</span><span class="delimiter">&quot;</span></span>, cidir, cidirrest,
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">install</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">NULL</span>);
  } <span class="keyword">else</span> <span class="keyword">if</span> (oldversionstatus == PKG_STAT_CONFIGFILES) { <i class="conum" data-value="1"></i><b>(1)</b>
    maintscript_new(pkg, PREINSTFILE, <span class="string"><span class="delimiter">&quot;</span><span class="content">pre-installation</span><span class="delimiter">&quot;</span></span>, cidir, cidirrest,
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">install</span><span class="delimiter">&quot;</span></span>,
                    versiondescribe(&amp;pkg-&gt;installed.version, vdew_nonambig),
                    versiondescribe(&amp;pkg-&gt;available.version, vdew_nonambig),
                    <span class="predefined-constant">NULL</span>);
  } <span class="keyword">else</span> { <i class="conum" data-value="1"></i><b>(1)</b>
    maintscript_new(pkg, PREINSTFILE, <span class="string"><span class="delimiter">&quot;</span><span class="content">pre-installation</span><span class="delimiter">&quot;</span></span>, cidir, cidirrest,
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">upgrade</span><span class="delimiter">&quot;</span></span>,
                    versiondescribe(&amp;pkg-&gt;installed.version, vdew_nonambig),
                    versiondescribe(&amp;pkg-&gt;available.version, vdew_nonambig),
                    <span class="predefined-constant">NULL</span>);
  }
  <span class="error">‚Ä¶</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>maintscript_new</code> is a variadic function whose latest arguments are passed to the maintainer script to provide context. For example, the <code>preinst</code> maintainer script can be called using one of these formats: <code>preinst install</code>, <code>preinst install &lt;old-version&gt;</code>, or <code>preinst upgrade &lt;old-version&gt;</code>. This allows the package developer to take different actions based on the current state of the package.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="4">
<li>
<p><strong>Unpack the new files, and at the same time back up the old files, so that if something goes wrong, they can be restored.</strong></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This step is similar to running the command <code>dpkg --unpack</code>. The unpacking process is simple to understand: extract every file present in the <code>data.tar</code> to their destination path. But things are not so simple as outlined by this comment:</p>
</div>
<div class="listingblock">
<div class="title">unpack.c#process_archive</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">  <span class="comment">/*
   * Now we unpack the archive, backing things up as we go.
   * For each file, we check to see if it already exists.
   * There are several possibilities:
   *
   * + We are trying to install a non-directory ...
   *  - It doesn't exist. In this case we simply extract it.
   *  - It is a plain file, device, symlink, &amp;c. We do an ‚Äòatomic
   *    overwrite‚Äô using link() and rename(), but leave a backup copy.
   *    Later, when we delete the backup, we remove it from any other
   *    packages' lists.
   *  - It is a directory. In this case it depends on whether we're
   *    trying to install a symlink or something else.
   *   = If we're not trying to install a symlink we move the directory
   *     aside and extract the node. Later, when we recursively remove
   *     the backed-up directory, we remove it from any other packages'
   *     lists.
   *   = If we are trying to install a symlink we do nothing - ie,
   *     dpkg will never replace a directory tree with a symlink. This
   *     is to avoid embarrassing effects such as replacing a directory
   *     tree with a link to a link to the original directory tree.
   * + We are trying to install a directory ...
   *  - It doesn't exist. We create it with the appropriate modes.
   *  - It exists as a directory or a symlink to one. We do nothing.
   *  - It is a plain file or a symlink (other than to a directory).
   *    We move it aside and create the directory. Later, when we
   *    delete the backup, we remove it from any other packages' lists.
   *
   *                   Install non-dir   Install symlink   Install dir
   *  Exists not               X               X                X
   *  File/node/symlink       LXR             LXR              BXR
   *  Directory               BXR              -                -
   *
   *    X: extract file/node/link/directory
   *   LX: atomic overwrite leaving backup
   *    B: ordinary backup
   *    R: later remove from other packages' lists
   *    -: do nothing
   *
   * After we've done this we go through the remaining things in the
   * lists of packages we're trying to remove (including the old
   * version of the current package). This happens in reverse order,
   * so that we process files before the directories (or symlinks-to-
   * directories) containing them.
   *
   * + If the thing is a conffile then we leave it alone for the purge
   *   operation.
   * + Otherwise, there are several possibilities too:
   *  - The listed thing does not exist. We ignore it.
   *  - The listed thing is a directory or a symlink to a directory.
   *    We delete it only if it isn't listed in any other package.
   *  - The listed thing is not a directory, but was part of the package
   *    that was upgraded, we check to make sure the files aren't the
   *    same ones from the old package by checking dev/inode
   *  - The listed thing is not a directory or a symlink to one (ie,
   *    it's a plain file, device, pipe, &amp;c, or a symlink to one, or a
   *    dangling symlink). We delete it.
   *
   * The removed packages' list becomes empty (of course, the new
   * version of the package we're installing will have a new list,
   * which replaces the old version's list).
   *
   * If at any stage we remove a file from a package's list, and the
   * package isn't one we're already processing, and the package's
   * list becomes empty as a result, we ‚Äòvanish‚Äô the package. This
   * means that we run its postrm with the ‚Äòdisappear‚Äô argument, and
   * put the package in the ‚Äònot-installed‚Äô state. If it had any
   * conffiles, their hashes and ownership will have been transferred
   * already, so we just ignore those and forget about them from the
   * point of view of the disappearing package.
   *
   * NOTE THAT THE OLD POSTRM IS RUN AFTER THE NEW PREINST, since the
   * files get replaced ‚Äòas we go‚Äô.
   */</span></code></pre>
</div>
</div>
<div id="wynk-conffiles" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About Conffiles</div>
<div class="paragraph">
<p>We still haven&#8217;t talked about conffiles. When upgrading a package, you want the package manager to overwrite the previous version of the files, except for configuration files. You don&#8217;t want to lose your customizations, don‚Äôt you?</p>
</div>
<div class="paragraph">
<p>A Debian archive can therefore include a file <code>conffiles</code> in the <code>DEBIAN/</code> directory to list a subset of files present in the <code>data.tar</code> archive. These "conffiles" are files that must be managed specially to take care of preserving user changes.</p>
</div>
<div class="paragraph">
<p>Conffiles explains the difference between the commands <code>dpkg remove</code> and <code>dpkg purge</code>. (The first command ignores conffiles while the second removes them completely.)</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/julien-sobczak/linux-packages-under-the-hood/tree/master/hello/2.1-1">version 2.1-1 of our package hello</a> defines a different version written in Python, which reads a configuration file <code>/etc/hello/settings.conf</code>, also present in the package. This conffile is referenced in <code>DEBIAN/conffiles</code>.</p>
</div>
<div class="paragraph">
<p>If we try to create this configuration file manually before installing this new version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# mkdir /etc/hello
vagrant# echo &quot;Language: English&quot; &gt; /etc/hello/settings.conf

vagrant# dpkg -i /vagrant/hello/hello_2.1-1_amd64.deb
Selecting previously unselected package hello.
(Reading database ... 25063 files and directories currently installed.)
Preparing to unpack .../hello/hello_2.1-1_amd64.deb ...
preinst says hello
Unpacking hello (2.1-1) ...
Setting up hello (2.1-1) ...

Configuration file '/etc/hello/settings.conf'
 ==&gt; File on system created by you or by a script.
 ==&gt; File also in package provided by package maintainer.
   What would you like to do about it ?  Your options are:
    Y or I  : install the package maintainers version
    N or O  : keep your currently-installed version
      D     : show the differences between the versions
      Z     : start a shell to examine the situation
 The default action is to keep your current version.
*** settings.conf (Y/I/N/O/D/Z) [default=N] ? Y
Installing new version of config file /etc/hello/settings.conf ...
postinst says hello

vagrant# cat /etc/hello/settings.conf
Language: French</code></pre>
</div>
</div>
<div class="paragraph">
<p>The package manager detects the conflict by keeping a checkum of the last installed version of every conffile (files named <code>md5sums</code> in the database) and asks the user what to do about it. Options exist to avoid the prompt and the default is, of course, to preserve existing conffiles.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The unpacking runs the command <code>dpkg-deb --fsys-tarfile</code> to extract the content of <code>data.tar</code>. The command sends each file to a pipe created in the same function <code>process_archive</code> and delegates to the function <code>tarobject</code> defined in <code>archives.c</code>, which implements all the rules presented in the previous comment. The code is rather obvious but is too long to introduce it in this article.</p>
</div>
<div class="paragraph">
<p>We can mention that the backup process consists in extracting files with a special extension like <code>.dpkg-tmp</code>, <code>.dpkg-old</code> and <code>.dpkg-new</code>. Files are renamed to their definitive name if no problem occurs, except for conffiles, which must wait until the last installation step to be renamed.</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="5">
<li>
<p><strong>If another version of the same package was installed before the new installation, execute the <code>postrm</code> script of the old package.</strong> Note that this script is executed after the <code>preinst</code> script of the new package, because new files are written at the same time old files are removed.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The execution code of the maintainer script <code>postrm</code> is similar to the previous scripts.</p>
</div>
<div class="paragraph">
<p>What is more interesting is what happens at the end of the unpacking step. Indeed, the Dpkg database is updated to reflect the changes.</p>
</div>
<div id="wynk-dpkg-database" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About the Dpkg Database</div>
<div class="paragraph">
<p>Dpkg maintains a database under <code>/var/lib/dpkg</code>, which regroups various files including the followings:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">file</th>
<th class="tableblock halign-left valign-top">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/status</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A DEB822 file containing the status information for all packages (i.e., the current state of each package and the fields in their <code>control</code> file).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/status-old</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The last backup of the <code>/var/lib/dpkg/status</code> file.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/available</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The list of packages available for installation or upgrade from external origins only if you are using <code>dselect</code> as your package manager frontend (instead of <code>apt</code> or <code>aptitude</code>). See <a href="https://wiki.debian.org/Teams/Dpkg/FAQ#Q:_What_is_the_dpkg_available_database.3F">details</a>. <em>(not described in this article)</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/diversions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The list of diversions used by <code>dpkg</code> and set by <code>dpkg-divert</code> to force a package file to be installed elsewhere. <em>(not described in this article)</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/statoverride</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The stats used by <code>dpkg</code> and set by <code>dpkg-statoverride</code> to change the default ownership and mode of the package files. <em>(not described in this article)</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In addition, for every installed package, Dpkg keeps a list of additional files:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">file</th>
<th class="tableblock halign-left valign-top">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/info/&lt;package_name&gt;.list</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The list of files and directories installed by the package (the <code>data.tar</code> listing)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/info/&lt;package_name&gt;.md5sums</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The list of MD5 hash values for files installed by the package. Used for example to detect if a conffile had been edited by the user.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/info/&lt;package_name&gt;.conffiles</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The list of configuration files. Same as the <code>conffiles</code> file under <code>DEBIAN/</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/info/&lt;package_name&gt;.{preinst, postinst, prerm, postrm}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Copies of the maintainer scripts present in the package under <code>DEBIAN/</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/dpkg/info/&lt;package_name&gt;.config</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://wiki.debian.org/ConfigPackages#debconf-generated_configuration_files">Debconf-generated configuration files</a> used only by a minority of packages. <em>(not described in this article)</em></p></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here are the different functions called to update the different files in the database:</p>
</div>
<div class="listingblock">
<div class="title">src/unpack.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">void</span> process_archive(<span class="directive">const</span> <span class="predefined-type">char</span> *filename) {
  <span class="error">‚Ä¶</span>

  <span class="comment">/* OK, now we can write the updated files-in-this package list,
   * since we've done away (hopefully) with all the old junk. */</span>
  write_filelist_except(pkg, &amp;pkg-&gt;available, newfiles_queue.head, <span class="integer">0</span>); <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="comment">/* We also install the new maintainer scripts, and any other
   * cruft that may have come along with the package. First
   * we go through the existing scripts replacing or removing
   * them as appropriate; then we go through the new scripts
   * (any that are left) and install them. */</span>
  pkg_infodb_update(pkg, cidir, cidirrest); <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="comment">/* We store now the checksums dynamically computed while unpacking. */</span>
  write_filehash_except(pkg, &amp;pkg-&gt;available, newfiles_queue.head, <span class="integer">0</span>); <i class="conum" data-value="3"></i><b>(3)</b>

  <span class="comment">/* Right, the package we've unpacked is now in a reasonable state.
   * The only thing that we have left to do with it is remove
   * backup files, and we can leave the user to fix that if and when
   * it happens (we leave the reinstall required flag, of course). */</span>
  pkg_set_status(pkg, PKG_STAT_UNPACKED);
  modstatdb_note(pkg); <i class="conum" data-value="4"></i><b>(4)</b>

  ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Edit the file <code>/var/lib/dpkg/info/hello.list</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Copy all files under <code>DEBIAN/</code> into <code>/var/lib/dpkg/info/</code> by prefixing them with the package name <code>hello.</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Edit the file <code>/var/lib/dpkg/info/hello.md5sums</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Update the field <code>Status</code> in <code>/var/lib/dpkg/status</code> for the package <code>hello</code> to set the value <code>install ok unpacked</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We are getting close to the end of the function <code>process_archive</code>. The last instruction is <code>enqueue_package(pkg)</code>. This function simply push a new package waiting to be configured in a queue. Since the <code>dpkg</code> command can be executed with several packages to install, the queue ensures all packages have been unpacked before proceeding to their final configuration.</p>
</div>
<div class="paragraph">
<p>We are now back to the <code>archivefiles</code> function:</p>
</div>
<div class="listingblock">
<div class="title">src/archives.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="predefined-type">int</span>
archivefiles(<span class="directive">const</span> <span class="predefined-type">char</span> *<span class="directive">const</span> *argv)
{
  <span class="predefined-type">int</span> i;

  modstatdb_open(msdbrw_readonly);

  <span class="keyword">for</span> (i = <span class="integer">0</span>; argv[i]; i++) {
    process_archive(argv[i]);
  }

  process_queue(); <i class="conum" data-value="1"></i><b>(1)</b>

  trigproc_run_deferred();
  modstatdb_shutdown();

  <span class="keyword">return</span> <span class="integer">0</span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We are here.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What follows is the data structure representing the queue:</p>
</div>
<div class="listingblock">
<div class="title">src/packages.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">static</span> <span class="keyword">struct</span> pkg_queue queue = { .head = <span class="predefined-constant">NULL</span>, .tail = <span class="predefined-constant">NULL</span>, .length = <span class="integer">0</span> }; <i class="conum" data-value="1"></i><b>(1)</b>


<span class="comment">/*
 * During the packages queue processing, the algorithm for deciding what to
 * configure first is as follows:
 *
 * Loop through all packages doing a ‚Äòtry 1‚Äô until we've been round and
 * nothing has been done, then do ‚Äòtry 2‚Äô, and subsequent ones likewise.
 * The incrementing of ‚Äòdependtry‚Äô is done by process_queue().
 *
 * Try 1:
 *   Are all dependencies of this package done? If so, do it.
 *   Are any of the dependencies missing or the wrong version?
 *     If so, abort (unless --force-depends, in which case defer).
 *   Will we need to configure a package we weren't given as an
 *     argument? If so, abort ‚îÄ except if --force-configure-any,
 *     in which case we add the package to the argument list.
 *   If none of the above, defer the package.
 *
 * Try 2:
 *   Find a cycle and break it (see above).
 *   Do as for try 1.
 *
 * Try 3:
 *   Start processing triggers if necessary.
 *   Do as for try 2.
 *
 * Try 4:
 *   Same as for try 3, but check trigger cycles even when deferring
 *   processing due to unsatisfiable dependencies.
 *
 * Try 5 (only if --force-depends-version):
 *   Same as for try 2, but don't mind version number in dependencies.
 *
 * Try 6 (only if --force-depends):
 *   Do anyway.
 */</span>
<span class="keyword">enum</span> dependtry {
    DEPEND_TRY_NORMAL = <span class="integer">1</span>,
    DEPEND_TRY_CYCLES = <span class="integer">2</span>,
    DEPEND_TRY_TRIGGERS = <span class="integer">3</span>,
    DEPEND_TRY_TRIGGERS_CYCLES = <span class="integer">4</span>,
    DEPEND_TRY_FORCE_DEPENDS_VERSION = <span class="integer">5</span>,
    DEPEND_TRY_FORCE_DEPENDS = <span class="integer">6</span>,
    DEPEND_TRY_LAST,
};
<span class="keyword">enum</span> dependtry dependtry = DEPEND_TRY_NORMAL; <i class="conum" data-value="2"></i><b>(2)</b>
<span class="predefined-type">int</span> sincenothing = <span class="integer">0</span>; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The global variable containing the packages to configure.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>These variables control the algorithm that decides which package must be configured first, which must be postponed, and when to abort the installation completely.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, the logic to empty the queue present in the function <code>process_queue</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/archives.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">void</span> process_queue(<span class="directive">void</span>) {
  <span class="keyword">struct</span> pkginfo *<span class="directive">volatile</span> pkg;
  <span class="directive">volatile</span> <span class="keyword">enum</span> action action_todo;

  <span class="keyword">while</span> (!pkg_queue_is_empty(&amp;queue)) {
    pkg = pkg_queue_pop(&amp;queue);

    ensure_package_clientdata(pkg);
    pkg-&gt;clientdata-&gt;enqueued = <span class="predefined-constant">false</span>;

    action_todo = cipaction-&gt;arg_int;

    <span class="keyword">if</span> (sincenothing++ &gt; queue.length * <span class="integer">3</span> + <span class="integer">2</span>) {
      <span class="comment">/* Make sure that even if we have exceeded the queue since not having
       * made any progress, we are not getting stuck trying to progress by
       * trigger processing, w/o jumping into the next dependtry. */</span>
      dependtry++;
      sincenothing = <span class="integer">0</span>;
      <span class="keyword">if</span> (dependtry &gt;= DEPEND_TRY_LAST)
        internerr(<span class="string"><span class="delimiter">&quot;</span><span class="content">exceeded dependtry %d (sincenothing=%d; queue.length=%d)</span><span class="delimiter">&quot;</span></span>,
                  dependtry, sincenothing, queue.length);
    } <span class="keyword">else</span> <span class="keyword">if</span> (sincenothing &gt; queue.length * <span class="integer">2</span> + <span class="integer">2</span>) {
      <span class="keyword">if</span> (dependtry &gt;= DEPEND_TRY_TRIGGERS &amp;&amp;
          progress_bytrigproc &amp;&amp; progress_bytrigproc-&gt;trigpend_head) {
        enqueue_package(pkg);
        pkg = progress_bytrigproc;
        progress_bytrigproc = <span class="predefined-constant">NULL</span>;
        action_todo = act_configure;
      } <span class="keyword">else</span> {
        dependtry++;
        sincenothing = <span class="integer">0</span>;
        <span class="keyword">if</span> (dependtry &gt;= DEPEND_TRY_LAST)
          internerr(<span class="string"><span class="delimiter">&quot;</span><span class="content">exceeded dependtry %d (sincenothing=%d, queue.length=%d)</span><span class="delimiter">&quot;</span></span>,
                    dependtry, sincenothing, queue.length);
      }
    }

    debug(dbg_general, <span class="string"><span class="delimiter">&quot;</span><span class="content">process queue pkg %s queue.len %d progress %d, try %d</span><span class="delimiter">&quot;</span></span>,
          pkg_name(pkg, pnaw_always), queue.length, sincenothing, dependtry);

    deferred_configure(pkg); <i class="conum" data-value="1"></i><b>(1)</b>
  }

  <span class="keyword">if</span> (queue.length)
    internerr(<span class="string"><span class="delimiter">&quot;</span><span class="content">finished package processing with non-empty queue length %d</span><span class="delimiter">&quot;</span></span>,
              queue.length);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>deferred_configure</code> is the main function doing the configuration and is the subject of the next step.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="6">
<li>
<p><strong>Configure the package.</strong></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Unpack the conffiles, and at the same time back up the old conffiles, so that they can be restored if something goes wrong.</p>
</li>
<li>
<p>Run <code>postinst</code> script, if provided by the package.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The last step uses the same code as the command <code>dpkg --configure</code>, which may be used to reconfigure a package that had already been unpacked.</p>
</div>
<div class="paragraph">
<p>The configuration step is implemented by the function <code>deferred_configure</code> which focuses on a single package to configure. If the configuration cannot proceed, the package will be enqueued to be reprocessed later or not. Here is a simplified version:</p>
</div>
<div class="listingblock">
<div class="title">src/configure.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="comment">/**
 * Process the deferred configure package.
 *
 * @param pkg The package to act on.
 */</span>
<span class="directive">void</span>
deferred_configure(<span class="keyword">struct</span> pkginfo *pkg)
{
    <span class="keyword">struct</span> varbuf aemsgs = VARBUF_INIT;
    <span class="keyword">struct</span> conffile *conff;
    <span class="keyword">struct</span> pkginfo *otherpkg;
    <span class="keyword">enum</span> dep_check ok;

    ok = dependencies_ok(pkg, <span class="predefined-constant">NULL</span>, &amp;aemsgs); <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">if</span> (ok == DEP_CHECK_DEFER) {
        varbuf_destroy(&amp;aemsgs);
        ensure_package_clientdata(pkg);
        pkg-&gt;clientdata-&gt;istobe = PKG_ISTOBE_INSTALLNEW;
        enqueue_package(pkg);
        <span class="keyword">return</span>;
    }

    <span class="comment">/*
     * At this point removal from the queue is confirmed. This
     * represents irreversible progress wrt trigger cycles. Only
     * packages in PKG_STAT_UNPACKED are automatically added to the
     * configuration queue, and during configuration and trigger
     * processing new packages can't enter into unpacked.
     */</span>
    sincenothing = <span class="integer">0</span>;


    printf(_(<span class="string"><span class="delimiter">&quot;</span><span class="content">Setting up %s (%s) ...</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>), pkg_name(pkg, pnaw_nonambig),
           versiondescribe(&amp;pkg-&gt;installed.version, vdew_nonambig));
    log_action(<span class="string"><span class="delimiter">&quot;</span><span class="content">configure</span><span class="delimiter">&quot;</span></span>, pkg, &amp;pkg-&gt;installed);


    <span class="keyword">if</span> (pkg-&gt;status == PKG_STAT_UNPACKED) {
        <span class="comment">/* On entry, the ‚Äònew‚Äô version of each conffile has been
         * unpacked as ‚Äò*.dpkg-new‚Äô, and the ‚Äòinstalled‚Äô version is
         * as-yet untouched in ‚Äò*‚Äô. The hash of the ‚Äòold distributed‚Äô
         * version is in the conffiles data for the package. If
         * ‚Äò*.dpkg-new‚Äô no longer exists we assume that we've
         * already processed this one. */</span>
        <span class="keyword">for</span> (conff = pkg-&gt;installed.conffiles; conff; conff = conff-&gt;next) {
            deferred_configure_conffile(pkg, conff); <i class="conum" data-value="2"></i><b>(2)</b>
        }

        pkg_set_status(pkg, PKG_STAT_HALFCONFIGURED);
        modstatdb_note(pkg);
    }

    maintscript_postinst(pkg, <span class="string"><span class="delimiter">&quot;</span><span class="content">configure</span><span class="delimiter">&quot;</span></span>,
      dpkg_version_is_informative(&amp;pkg-&gt;configversion) ?
            versiondescribe(&amp;pkg-&gt;configversion, vdew_nonambig) :
          <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>,
      <span class="predefined-constant">NULL</span>); <i class="conum" data-value="3"></i><b>(3)</b>

    pkg_reset_eflags(pkg);
    post_postinst_tasks(pkg, PKG_STAT_INSTALLED); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In case of a missing dependency, the installation will abort only at this step, after the unpacking of the package files.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The function <code>deferred_configure_conffile</code> renames the conffiles still ending with the suffix <code>.dpkg-new</code> created during the unpacking. This function also shows the confirmation prompt.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Run the <code>postinst</code> maintainer script.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Change the status to <code>PKG_STAT_INSTALLED</code> and force the update in the <code>status</code> database file.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The installation of our package is now completed. We can check the package has been installed by running the <code>hello</code> command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# hello
hello world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or by using the command <code>dpkg</code> to get the status of the package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# dpkg -s hello
Package: hello
Status: install ok unpacked
Priority: optional
Section: base
Maintainer: Julien Sobczak
Architecture: amd64
Version: 1.1-1
Description: Say Hello</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sect-part2-go">Case Study</h3>
<div class="paragraph">
<p>What follows is a minimal rewrite in Go of the code covered in this second part. The full code is available on GitHub in the repository <a href="https://github.com/julien-sobczak/linux-packages-under-the-hood">julien-sobczak/linux-packages-under-the-hood</a>.</p>
</div>
<div class="paragraph">
<p>But first, let&#8217;s remove the package or we will not be able to test our program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh"># dpkg -r hello
(Reading database ... 26963 files and directories currently installed.)
Removing hello (1.1-1) ...

# hello
bash: /usr/bin/hello: No such file or directory</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the code:</p>
</div>
<div class="listingblock">
<div class="title">main.go</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="go"><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string"><span class="delimiter">&quot;</span><span class="content">archive/tar</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">bytes</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">fmt</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">io</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">log</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">os</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">os/exec</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">path/filepath</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">strings</span><span class="delimiter">&quot;</span></span>

    <span class="string"><span class="delimiter">&quot;</span><span class="content">github.com/blakesmith/ar</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">github.com/julien-sobczak/deb822</span><span class="delimiter">&quot;</span></span>
)

<span class="keyword">func</span> main() {
    <span class="comment">// This program expects one or more package files to install.</span>
    <span class="keyword">if</span> <span class="predefined">len</span>(os.Args) &lt; <span class="integer">2</span> {
        log.Fatalf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Missing package archive(s)</span><span class="delimiter">&quot;</span></span>)
    }

    <span class="comment">// Read the DPKG database</span>
    db, _ := loadDatabase()

    <span class="comment">// Unpack and configure the archive(s)</span>
    <span class="keyword">for</span> _, archivePath := <span class="keyword">range</span> os.Args[<span class="integer">1</span>:] {
        processArchive(db, archivePath)
    }

    <span class="comment">// For simplicity reasons, we don't manage a queue to defer</span>
    <span class="comment">// the configuration of packages like in the official code.</span>
}

<span class="comment">//</span>
<span class="comment">// Dpkg Database</span>
<span class="comment">//</span>

<span class="keyword">type</span> Database <span class="keyword">struct</span> {
    <span class="comment">// File /var/lib/dpkg/status</span>
    Status deb822.Document
    <span class="comment">// Packages under /var/lib/dpkg/info/</span>
    Packages []*PackageInfo
}

<span class="keyword">type</span> PackageInfo <span class="keyword">struct</span> {
    Paragraph deb822.Paragraph <span class="comment">// Extracted section in /var/lib/dpkg/status</span>

    <span class="comment">// info</span>
    Files             []<span class="predefined-type">string</span>          <span class="comment">// File &lt;name&gt;.list</span>
    Conffiles         []<span class="predefined-type">string</span>          <span class="comment">// File &lt;name&gt;.conffiles</span>
    MaintainerScripts <span class="keyword">map</span>[<span class="predefined-type">string</span>]<span class="predefined-type">string</span> <span class="comment">// File &lt;name&gt;.{preinst,prerm,...}</span>

    Status      <span class="predefined-type">string</span> <span class="comment">// Current status (as present in `Paragraph`)</span>
    StatusDirty <span class="predefined-type">bool</span>   <span class="comment">// True to ask for sync</span>
}

<span class="keyword">func</span> (p *PackageInfo) Name() <span class="predefined-type">string</span> {
    <span class="comment">// Extract the package name from its section in /var/lib/dpkg/status</span>
    <span class="keyword">return</span> p.Paragraph.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Package</span><span class="delimiter">&quot;</span></span>)
}

<span class="keyword">func</span> (p *PackageInfo) Version() <span class="predefined-type">string</span> {
    <span class="comment">// Extract the package version from its section in /var/lib/dpkg/status</span>
    <span class="keyword">return</span> p.Paragraph.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Version</span><span class="delimiter">&quot;</span></span>)
}

<span class="comment">// isConffile determines if a file must be processed as a conffile.</span>
<span class="keyword">func</span> (p *PackageInfo) isConffile(path <span class="predefined-type">string</span>) <span class="predefined-type">bool</span> {
    <span class="keyword">for</span> _, conffile := <span class="keyword">range</span> p.Conffiles {
        <span class="keyword">if</span> path == conffile {
            <span class="keyword">return</span> <span class="predefined-constant">true</span>
        }
    }
    <span class="keyword">return</span> <span class="predefined-constant">false</span>
}

<span class="comment">// InfoPath returns the path of a file under /var/lib/dpkg/info/.</span>
<span class="comment">// Ex: &quot;list&quot; =&gt; /var/lib/dpkg/info/hello.list</span>
<span class="keyword">func</span> (p *PackageInfo) InfoPath(filename <span class="predefined-type">string</span>) <span class="predefined-type">string</span> {
    <span class="keyword">return</span> filepath.Join(<span class="string"><span class="delimiter">&quot;</span><span class="content">/var/lib/dpkg</span><span class="delimiter">&quot;</span></span>, p.Name()+<span class="string"><span class="delimiter">&quot;</span><span class="content">.</span><span class="delimiter">&quot;</span></span>+filename)
}

<span class="comment">// We now add a method to change the package status</span>
<span class="comment">// and make sure the section in the status file is updated too.</span>
<span class="comment">// This method will be used several times at the different steps</span>
<span class="comment">// of the installation process.</span>

<span class="keyword">func</span> (p *PackageInfo) SetStatus(<span class="predefined">new</span> <span class="predefined-type">string</span>) {
    p.Status = <span class="predefined">new</span>
    p.StatusDirty = <span class="predefined-constant">true</span>
    <span class="comment">// Override in DEB 822 document used to write the status file</span>
    old := p.Paragraph.Values[<span class="string"><span class="delimiter">&quot;</span><span class="content">Status</span><span class="delimiter">&quot;</span></span>]
    parts := strings.Split(old, <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>)
    newStatus := fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%s %s %s</span><span class="delimiter">&quot;</span></span>, parts[<span class="integer">0</span>], parts[<span class="integer">1</span>], <span class="predefined">new</span>)
    p.Paragraph.Values[<span class="string"><span class="delimiter">&quot;</span><span class="content">Status</span><span class="delimiter">&quot;</span></span>] = newStatus
}

<span class="comment">// Now, we are ready to read the database directory to initialize the structs.</span>

<span class="keyword">func</span> loadDatabase() (*Database, <span class="predefined-type">error</span>) {
    <span class="comment">// Load the status file</span>
    f, _ := os.Open(<span class="string"><span class="delimiter">&quot;</span><span class="content">/var/lib/dpkg/status</span><span class="delimiter">&quot;</span></span>)
    parser, _ := deb822.NewParser(f)
    status, _ := parser.Parse()

    <span class="comment">// Read the info directory</span>
    <span class="keyword">var</span> packages []*PackageInfo
    <span class="keyword">for</span> _, statusParagraph := <span class="keyword">range</span> status.Paragraphs {
        statusField := statusParagraph.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Status</span><span class="delimiter">&quot;</span></span>) <span class="comment">// install ok installed</span>
        statusValues := strings.Split(statusField, <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>)

        pkg := PackageInfo{
            Paragraph:         statusParagraph,
            MaintainerScripts: <span class="predefined">make</span>(<span class="keyword">map</span>[<span class="predefined-type">string</span>]<span class="predefined-type">string</span>),
            Status:            statusValues[<span class="integer">2</span>],
            StatusDirty:       <span class="predefined-constant">false</span>,
        }

        <span class="comment">// Read the configuration files</span>
        pkg.Files, _ = ReadLines(pkg.InfoPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">list</span><span class="delimiter">&quot;</span></span>))
        pkg.Conffiles, _ = ReadLines(pkg.InfoPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">conffiles</span><span class="delimiter">&quot;</span></span>))

        <span class="comment">// Read the maintainer scripts</span>
        maintainerScripts := []<span class="predefined-type">string</span>{<span class="string"><span class="delimiter">&quot;</span><span class="content">preinst</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">postinst</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">prerm</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">postrm</span><span class="delimiter">&quot;</span></span>}
        <span class="keyword">for</span> _, script := <span class="keyword">range</span> maintainerScripts {
            scriptPath := pkg.InfoPath(script)
            <span class="keyword">if</span> _, err := os.Stat(scriptPath); !os.IsNotExist(err) {
                content, err := os.ReadFile(scriptPath)
                <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
                    <span class="keyword">return</span> <span class="predefined-constant">nil</span>, err
                }
                pkg.MaintainerScripts[script] = <span class="predefined-type">string</span>(content)
            }
        }
        packages = <span class="predefined">append</span>(packages, &amp;pkg)
    }

    <span class="comment">// We have read everything that interest us and are ready</span>
    <span class="comment">// to populate the Database struct.</span>

    <span class="keyword">return</span> &amp;Database{
        Status:   status,
        Packages: packages,
    }, <span class="predefined-constant">nil</span>
}

<span class="comment">// Now we are ready to process an archive to install.</span>

<span class="keyword">func</span> processArchive(db *Database, archivePath <span class="predefined-type">string</span>) <span class="predefined-type">error</span> {

    <span class="comment">// Read the Debian archive file</span>
    f, err := os.Open(archivePath)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }
    <span class="keyword">defer</span> f.Close()
    reader := ar.NewReader(f)

    <span class="comment">// Skip debian-binary</span>
    reader.Next()

    <span class="comment">// control.tar</span>
    reader.Next()
    <span class="keyword">var</span> bufControl bytes.Buffer
    io.Copy(&amp;bufControl, reader)

    pkg, err := parseControl(db, bufControl)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }

    <span class="comment">// Add the new package in the database</span>
    db.Packages = <span class="predefined">append</span>(db.Packages, pkg)
    db.Sync()

    <span class="comment">// data.tar</span>
    reader.Next()
    <span class="keyword">var</span> bufData bytes.Buffer
    io.Copy(&amp;bufData, reader)

    fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Preparing to unpack %s ...</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, filepath.Base(archivePath))

    <span class="keyword">if</span> err := pkg.Unpack(bufData); err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }
    <span class="keyword">if</span> err := pkg.Configure(); err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }

    db.Sync()

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="comment">// parseControl processes the control.tar archive.</span>
<span class="keyword">func</span> parseControl(db *Database, buf bytes.Buffer) (*PackageInfo, <span class="predefined-type">error</span>) {

    <span class="comment">// The control.tar archive contains the most important files</span>
    <span class="comment">// we need to install the package.</span>
    <span class="comment">// We need to extract metadata from the control file, determine</span>
    <span class="comment">// if the package contains conffiles and maintainer scripts.</span>

    pkg := PackageInfo{
        MaintainerScripts: <span class="predefined">make</span>(<span class="keyword">map</span>[<span class="predefined-type">string</span>]<span class="predefined-type">string</span>),
        Status:            <span class="string"><span class="delimiter">&quot;</span><span class="content">not-installed</span><span class="delimiter">&quot;</span></span>,
        StatusDirty:       <span class="predefined-constant">true</span>,
    }

    tr := tar.NewReader(&amp;buf)

    <span class="keyword">for</span> {
        hdr, err := tr.Next()
        <span class="keyword">if</span> err == io.EOF {
            <span class="keyword">break</span> <span class="comment">// End of archive</span>
        }
        <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
            <span class="keyword">return</span> <span class="predefined-constant">nil</span>, err
        }

        <span class="comment">// Read the file content</span>
        <span class="keyword">var</span> buf bytes.Buffer
        <span class="keyword">if</span> _, err := io.Copy(&amp;buf, tr); err != <span class="predefined-constant">nil</span> {
            <span class="keyword">return</span> <span class="predefined-constant">nil</span>, err
        }

        <span class="keyword">switch</span> filepath.Base(hdr.Name) {
        <span class="keyword">case</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">control</span><span class="delimiter">&quot;</span></span>:
            parser, _ := deb822.NewParser(strings.NewReader(buf.String()))
            document, _ := parser.Parse()
            controlParagraph := document.Paragraphs[<span class="integer">0</span>]

            <span class="comment">// Copy control fields and add the Status field in second position</span>
            pkg.Paragraph = deb822.Paragraph{
                Values: <span class="predefined">make</span>(<span class="keyword">map</span>[<span class="predefined-type">string</span>]<span class="predefined-type">string</span>),
            }

            <span class="comment">// Make sure the field &quot;Package' comes first, then &quot;Status&quot;,</span>
            <span class="comment">// then remaining fields.</span>
            pkg.Paragraph.Order = <span class="predefined">append</span>(
                pkg.Paragraph.Order, <span class="string"><span class="delimiter">&quot;</span><span class="content">Package</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Status</span><span class="delimiter">&quot;</span></span>)
            pkg.Paragraph.Values[<span class="string"><span class="delimiter">&quot;</span><span class="content">Package</span><span class="delimiter">&quot;</span></span>] = controlParagraph.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Package</span><span class="delimiter">&quot;</span></span>)
            pkg.Paragraph.Values[<span class="string"><span class="delimiter">&quot;</span><span class="content">Status</span><span class="delimiter">&quot;</span></span>] = <span class="string"><span class="delimiter">&quot;</span><span class="content">install ok non-installed</span><span class="delimiter">&quot;</span></span>
            <span class="keyword">for</span> _, field := <span class="keyword">range</span> controlParagraph.Order {
                <span class="keyword">if</span> field == <span class="string"><span class="delimiter">&quot;</span><span class="content">Package</span><span class="delimiter">&quot;</span></span> {
                    <span class="keyword">continue</span>
                }
                pkg.Paragraph.Order = <span class="predefined">append</span>(pkg.Paragraph.Order, field)
                pkg.Paragraph.Values[field] = controlParagraph.Value(field)
            }
        <span class="keyword">case</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">conffiles</span><span class="delimiter">&quot;</span></span>:
            pkg.Conffiles = SplitLines(buf.String())
        <span class="keyword">case</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">prerm</span><span class="delimiter">&quot;</span></span>:
            <span class="keyword">fallthrough</span>
        <span class="keyword">case</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">preinst</span><span class="delimiter">&quot;</span></span>:
            <span class="keyword">fallthrough</span>
        <span class="keyword">case</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">postinst</span><span class="delimiter">&quot;</span></span>:
            <span class="keyword">fallthrough</span>
        <span class="keyword">case</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">postrm</span><span class="delimiter">&quot;</span></span>:
            pkg.MaintainerScripts[filepath.Base(hdr.Name)] = buf.String()
        }
    }

    <span class="keyword">return</span> &amp;pkg, <span class="predefined-constant">nil</span>
}

<span class="comment">// Unpack processes the data.tar archive.</span>
<span class="keyword">func</span> (p *PackageInfo) Unpack(buf bytes.Buffer) <span class="predefined-type">error</span> {

    <span class="comment">// The unpacking process consists in extracting all files</span>
    <span class="comment">// in data.tar to their final destination, except for conffiles,</span>
    <span class="comment">// which are copied with a special extension that will be removed</span>
    <span class="comment">// in the configure step.</span>

    <span class="keyword">if</span> err := p.runMaintainerScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">preinst</span><span class="delimiter">&quot;</span></span>); err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }

    fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Unpacking %s (%s) ...</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, p.Name(), p.Version())

    tr := tar.NewReader(&amp;buf)
    <span class="keyword">for</span> {
        hdr, err := tr.Next()
        <span class="keyword">if</span> err == io.EOF {
            <span class="keyword">break</span> <span class="comment">// End of archive</span>
        }
        <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
            <span class="keyword">return</span> err
        }

        <span class="keyword">var</span> buf bytes.Buffer
        <span class="keyword">if</span> _, err := io.Copy(&amp;buf, tr); err != <span class="predefined-constant">nil</span> {
            <span class="keyword">return</span> err
        }

        <span class="keyword">switch</span> hdr.Typeflag {
        <span class="keyword">case</span> tar.TypeReg:
            dest := hdr.Name
            <span class="keyword">if</span> strings.HasPrefix(dest, <span class="string"><span class="delimiter">&quot;</span><span class="content">./</span><span class="delimiter">&quot;</span></span>) {
                <span class="comment">// ./usr/bin/hello =&gt; /usr/bin/hello</span>
                dest = dest[<span class="integer">1</span>:]
            }
            <span class="keyword">if</span> !strings.HasPrefix(dest, <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>) {
                <span class="comment">// usr/bin/hello =&gt; /usr/bin/hello</span>
                dest = <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span> + dest
            }

            tmpdest := dest
            <span class="keyword">if</span> p.isConffile(tmpdest) {
                <span class="comment">// Extract using the extension .dpkg-new</span>
                tmpdest += <span class="string"><span class="delimiter">&quot;</span><span class="content">.dpkg-new</span><span class="delimiter">&quot;</span></span>
            }

            <span class="keyword">if</span> err := os.MkdirAll(filepath.Dir(tmpdest), <span class="octal">0755</span>); err != <span class="predefined-constant">nil</span> {
                log.Fatalf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to unpack directory %s: %v</span><span class="delimiter">&quot;</span></span>, tmpdest, err)
            }

            content := buf.Bytes()
            <span class="keyword">if</span> err := os.WriteFile(tmpdest, content, <span class="octal">0755</span>); err != <span class="predefined-constant">nil</span> {
                log.Fatalf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to unpack file %s: %v</span><span class="delimiter">&quot;</span></span>, tmpdest, err)
            }

            p.Files = <span class="predefined">append</span>(p.Files, dest)
        }
    }

    p.SetStatus(<span class="string"><span class="delimiter">&quot;</span><span class="content">unpacked</span><span class="delimiter">&quot;</span></span>)
    p.Sync()

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="comment">// Configure processes the conffiles.</span>
<span class="keyword">func</span> (p *PackageInfo) Configure() <span class="predefined-type">error</span> {

    <span class="comment">// The configure process consists in renaming the conffiles</span>
    <span class="comment">// unpacked at the previous step.</span>
    <span class="comment">//</span>
    <span class="comment">// We ignore some implementation concerns like checking if a conffile</span>
    <span class="comment">// has been updated using the last known checksum.</span>

    fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Setting up %s (%s) ...</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, p.Name(), p.Version())

    <span class="comment">// Rename conffiles</span>
    <span class="keyword">for</span> _, conffile := <span class="keyword">range</span> p.Conffiles {
        os.Rename(conffile+<span class="string"><span class="delimiter">&quot;</span><span class="content">.dpkg-new</span><span class="delimiter">&quot;</span></span>, conffile)
    }
    p.SetStatus(<span class="string"><span class="delimiter">&quot;</span><span class="content">half-configured</span><span class="delimiter">&quot;</span></span>)
    p.Sync()

    <span class="comment">// Run maintainer script</span>
    <span class="keyword">if</span> err := p.runMaintainerScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">postinst</span><span class="delimiter">&quot;</span></span>); err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }
    p.SetStatus(<span class="string"><span class="delimiter">&quot;</span><span class="content">installed</span><span class="delimiter">&quot;</span></span>)
    p.Sync()

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="keyword">func</span> (p *PackageInfo) runMaintainerScript(name <span class="predefined-type">string</span>) <span class="predefined-type">error</span> {

    <span class="comment">// The control.tar file can contains scripts to be run at</span>
    <span class="comment">// specific moments. This function uses the standard Go library</span>
    <span class="comment">// to run the `sh` command with a maintainer scrpit as an argument.</span>

    <span class="keyword">if</span> _, ok := p.MaintainerScripts[name]; !ok {
        <span class="comment">// Nothing to run</span>
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>
    }

    out, err := exec.Command(<span class="string"><span class="delimiter">&quot;</span><span class="content">/bin/sh</span><span class="delimiter">&quot;</span></span>, p.InfoPath(name)).Output()
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }
    fmt.Print(<span class="predefined-type">string</span>(out))

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="comment">// We have covered the different steps of the installation process.</span>
<span class="comment">// We still need to write the code to sync the database.</span>

<span class="keyword">func</span> (d *Database) Sync() <span class="predefined-type">error</span> {
    newStatus := deb822.Document{
        Paragraphs: []deb822.Paragraph{},
    }

    <span class="comment">// Sync the /var/lib/dpkg/info directory</span>
    <span class="keyword">for</span> _, pkg := <span class="keyword">range</span> d.Packages {
        newStatus.Paragraphs = <span class="predefined">append</span>(newStatus.Paragraphs, pkg.Paragraph)

        <span class="keyword">if</span> pkg.StatusDirty {
            <span class="keyword">if</span> err := pkg.Sync(); err != <span class="predefined-constant">nil</span> {
                <span class="keyword">return</span> err
            }
        }
    }

    <span class="comment">// Make a new version of /var/lib/dpkg/status</span>
    os.Rename(<span class="string"><span class="delimiter">&quot;</span><span class="content">/var/lib/dpkg/status</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/var/lib/dpkg/status-old</span><span class="delimiter">&quot;</span></span>)
    formatter := deb822.NewFormatter()
    formatter.SetFoldedFields(<span class="string"><span class="delimiter">&quot;</span><span class="content">Description</span><span class="delimiter">&quot;</span></span>)
    formatter.SetMultilineFields(<span class="string"><span class="delimiter">&quot;</span><span class="content">Conffiles</span><span class="delimiter">&quot;</span></span>)
    <span class="keyword">if</span> err := os.WriteFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">/var/lib/dpkg/status</span><span class="delimiter">&quot;</span></span>,
        []<span class="predefined-type">byte</span>(formatter.Format(newStatus)), <span class="octal">0644</span>); err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="keyword">func</span> (p *PackageInfo) Sync() <span class="predefined-type">error</span> {
    <span class="comment">// This function synchronizes the files under /var/lib/dpkg/info</span>
    <span class="comment">// for a single package.</span>

    <span class="comment">// Write &lt;package&gt;.list</span>
    <span class="keyword">if</span> err := os.WriteFile(p.InfoPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">list</span><span class="delimiter">&quot;</span></span>),
        []<span class="predefined-type">byte</span>(MergeLines(p.Files)), <span class="octal">0644</span>); err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }

    <span class="comment">// Write &lt;package&gt;.conffiles</span>
    <span class="keyword">if</span> err := os.WriteFile(p.InfoPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">conffiles</span><span class="delimiter">&quot;</span></span>),
        []<span class="predefined-type">byte</span>(MergeLines(p.Conffiles)), <span class="octal">0644</span>); err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }

    <span class="comment">// Write &lt;package&gt;.{preinst,prerm,postinst,postrm}</span>
    <span class="keyword">for</span> name, content := <span class="keyword">range</span> p.MaintainerScripts {
        err := os.WriteFile(p.InfoPath(name), []<span class="predefined-type">byte</span>(content), <span class="octal">0755</span>)
        <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
            <span class="keyword">return</span> err
        }
    }

    p.StatusDirty = <span class="predefined-constant">false</span>
    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="comment">/* Utility functions */</span>

<span class="keyword">func</span> ReadLines(path <span class="predefined-type">string</span>) ([]<span class="predefined-type">string</span>, <span class="predefined-type">error</span>) {
    <span class="keyword">if</span> _, err := os.Stat(path); !os.IsNotExist(err) {
        content, err := os.ReadFile(path)
        <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
            <span class="keyword">return</span> <span class="predefined-constant">nil</span>, err
        }
        <span class="keyword">return</span> SplitLines(<span class="predefined-type">string</span>(content)), <span class="predefined-constant">nil</span>
    }
    <span class="keyword">return</span> <span class="predefined-constant">nil</span>, <span class="predefined-constant">nil</span>
}

<span class="keyword">func</span> SplitLines(content <span class="predefined-type">string</span>) []<span class="predefined-type">string</span> {
    <span class="keyword">var</span> lines []<span class="predefined-type">string</span>
    <span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(<span class="predefined-type">string</span>(content), <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">if</span> strings.TrimSpace(line) == <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> {
            <span class="keyword">continue</span>
        }
        lines = <span class="predefined">append</span>(lines, line)
    }
    <span class="keyword">return</span> lines
}

<span class="keyword">func</span> MergeLines(lines []<span class="predefined-type">string</span>) <span class="predefined-type">string</span> {
    <span class="keyword">return</span> strings.Join(lines, <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>) + <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s test the new command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ go build -o dpkg main.go
$ vagrant destroy -f # Recreate the VM
$ vagrant up         # to force a fresh installation.
vagrant$ sudo su
vagrant# /vagrant/dpkg /vagrant/hello.deb
Preparing to unpack hello.deb ...
preinst says hello
Unpacking hello (1.1-1) ...
Setting up hello (1.1-1) ...
postinst says hello

vagrant# hello
hello world

vagrant# dpkg -s hello
Package: hello
Status: install ok installed
Priority: optional
Section: base
Maintainer: Julien Sobczak
Architecture: amd64
Version: 1.1-1
Description: Say Hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our package has been correctly installed. The standard <code>dpkg</code> command recognized it and can be used to remove the package like any other installed package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# dpkg -r hello
(Reading database ... 25063 files and directories currently installed.)
Removing hello (1.1-1) ...
prerm says hello
postrm says hello

vagrant# hello
bash: /usr/bin/hello: No such file or directory</code></pre>
</div>
</div>
<div class="paragraph">
<p>üéâ <strong>We have finished with the command <code>dpkg</code>.</strong> We succeeded in creating a package manually and installed it using a basic Go program. We have a better understanding of how <code>dpkg</code> is working and what information is available in its database. Now, we will have a look at the package manager frontend <code>apt</code> to understand how these programs are working together to install a package.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sect-part3">What happens when you install a package using <code>apt</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main reason to use <code>apt</code> is for the dependency management support. This command understands that in order to install a given package, other packages may need to be installed too, and <code>apt</code> can download and install them. In practice, <code>dpkg</code> is called a package manager and <code>apt</code> is called a frontend package manager.</p>
</div>
<div id="wynk-apt-get-aptitude" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About <code>apt</code>, <code>apt-get</code>, <code>aptitude</code></div>
<div class="paragraph">
<p>APT is a vast project started in 1997 organized around a core library. The command <code>apt-get</code> was the first frontend developed within the project, and <code>apt</code> is the second command provided by APT, which overcomes some design mistakes of <code>apt-get</code>, for example,  <code>apt</code> refuses to install dependencies that were not installed beforehand during an upgrade. Under the hood, both tools are built on top of the core library and are thus very close.</p>
</div>
<div class="paragraph">
<p>External projects like <code>aptitude</code> have been developed later to support new features like auto-removing of packages when they are no longer required, but most of these features are now available in <code>apt</code> too.</p>
</div>
<div class="paragraph">
<p>The most widespread command remains <code>apt</code>, and it is the one that we will use in this section.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apt (<code>apt</code> and <code>apt-get</code>) Official Repository: <a href="https://salsa.debian.org/apt-team/apt" class="bare">https://salsa.debian.org/apt-team/apt</a></p>
</li>
<li>
<p>Apt GitHub Mirror: <a href="https://github.com/Debian/apt" class="bare">https://github.com/Debian/apt</a></p>
</li>
<li>
<p>Aptitude Official Repository: <a href="https://salsa.debian.org/apt-team/aptitude" class="bare">https://salsa.debian.org/apt-team/aptitude</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Further documentation</em>: <a href="https://raphaelhertzog.com/2011/06/20/apt-get-aptitude-%e2%80%a6-pick-the-right-debian-package-manager-for-you/">apt-get, aptitude, ‚Ä¶ pick the right Debian package manager for you, Rapha√´l Hertzog</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>APT makes software available to the user by doing the dirty work of downloading all the required packages and installing them using <code>dpkg</code> in the correct order to respect the dependencies. The scope of APT is larger than Dpkg and its behavior is highly configurable.</p>
</div>
<div id="wynk-apt-configuration-files" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About APT Configuration Files</div>
<div class="paragraph">
<p>APT configuration resides under <code>/etc/apt/</code>, which contains the following files:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>apt.conf</code> and <code>apt.conf.d/</code>: The main configuration files where hundred of options are available (<a href="#wynk-apt-configuration-options">more about them soon</a>). The command <code>apt-config dump</code> can be used to view all available options with their default values:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ apt-config dump
...
Dir &quot;/&quot;;
Dir::State &quot;var/lib/apt&quot;;
Dir::State::status &quot;/var/lib/dpkg/status&quot;;
Dir::Cache &quot;var/cache/apt&quot;;
Dir::Etc &quot;etc/apt&quot;;
Dir::Etc::sourcelist &quot;sources.list&quot;;
Dir::Etc::sourceparts &quot;sources.list.d&quot;;
Dir::Etc::main &quot;apt.conf&quot;;
Dir::Etc::parts &quot;apt.conf.d&quot;;
Dir::Etc::preferences &quot;preferences&quot;;
Dir::Etc::preferencesparts &quot;preferences.d&quot;;
Dir::Etc::trusted &quot;trusted.gpg&quot;;
Dir::Etc::trustedparts &quot;trusted.gpg.d&quot;;
...</code></pre>
</div>
</div>
</li>
<li>
<p><code>sources.list</code> and <code>sources.list.d/</code>: lists of repositories (<a href="#wynk-repositories">more about them soon</a>). Here are the default repositories on my Debian server:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ cat /etc/apt/sources.list
deb http://deb.debian.org/debian buster main
deb-src http://deb.debian.org/debian buster main
deb http://security.debian.org/debian-security buster-security main
deb-src http://security.debian.org/debian-security buster-security main
deb http://deb.debian.org/debian buster-updates main
deb-src http://deb.debian.org/debian buster-updates main
deb http://deb.debian.org/debian buster-backports main
deb-src http://deb.debian.org/debian buster-backports main</code></pre>
</div>
</div>
</li>
<li>
<p><code>preferences</code> and <code>preferences.d/</code>: APT pinning is the only available preference. By default, when multiple repositories are configured, a package can exist in several of them and APT applies logic to decide which one must be installed. Pinning allows you to change this logic (called a policy) for some packages. The command <code>apt-cache policy [pkg]</code> can be used to view the global policy when called without argument:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ apt-cache policy
Package files:
 100 /var/lib/dpkg/status
     release a=now
 500 http://security.debian.org/debian-security buster-security/main
     amd64 Packages
     release o=Debian,a=testing-security,n=buster-security,
     l=Debian-Security,c=main,b=amd64
     origin security.debian.org
 500 http://deb.debian.org/debian buster/main amd64 Packages
     release o=Debian,a=testing,n=buster,l=Debian,c=main,b=amd64
     origin deb.debian.org</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create preferences files to privilege a specific repository for a given package or to prevent this package to be upgraded. <em>(not covered in this article)</em></p>
</div>
</li>
<li>
<p><code>trusted.gpg</code> and <code>trusted.gpg.d/</code>: keys for secure authentication of packages (known as "Secure APT" and used in Debian since 2005). The command <code>apt-key</code> can be used to show the keys, and to add or remove a key. APT uses public-key (asymmetric) cryptography using GPG:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ ls -1 /etc/apt/trusted.gpg.d/
debian-archive-buster-automatic.gpg
debian-archive-buster-security-automatic.gpg
debian-archive-buster-stable.gpg
debian-archive-stretch-automatic.gpg
debian-archive-stretch-security-automatic.gpg
debian-archive-stretch-stable.gpg</code></pre>
</div>
</div>
<div class="paragraph">
<p>When installing a package, APT retrieves the package from an external repository and the <code>Release</code> file, which is the entry file to find <code>Packages</code> index files, may have be altered (which means checking the MD5 sums inside these index files is useless if we can&#8217;t guarantee that the <code>Release</code> file is safe against a man-in-the-middle attack). This is the goal of secure APT. Concretely, secure APT always downloads a <code>Release.gpg</code> file if existing before downloading a <code>Release</code> file. (NB: The file <code>InRelease</code> had now merged the intent of these two deprecated files.) Using cryptography, APT can be sure that the file is safe and can trust the MD5 sums present inside it to check other files like <code>Packages</code> files. Otherwise, APT will complain with the following message you have probably encountered before:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh"># When adding a new repository in `/etc/apt/sources.list.d/`:
W: GPG error: http://ftp.us.debian.org testing Release:
 The following signatures couldn't be verified
 because the public key is not available:
 NO_PUBKEY 010908312D230C5F
# When installing a new package from this repository:
WARNING: The following packages cannot be authenticated!
  libglib-perl libgtk2-perl
Install these packages without verification [y/N]?</code></pre>
</div>
</div>
</li>
<li>
<p><code>auth.conf</code> and <code>auth.conf.d/</code>: APT configuration and repositories list must be accessible to any user on the system but some repositories may require login information to connect, which are stored in these restrictive files. For example, instead of specifying the user/password <code>apt:debian</code> in the source list file directly (<code>deb <a href="https://apt:debian@example.org/debian" class="bare">https://apt:debian@example.org/debian</a> buster main</code>), you can create an entry in <code>auth.conf</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>machine example.org
login apt
password debian</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>(not covered in this article)</em></p>
</div>
</li>
<li>
<p><code>listchanges.conf</code> and <code>listchanges.conf.d</code>: Only used by the command <code>apt-listchanges</code> to show what has been changed in a new version of a Debian package, as compared to the version currently installed on the system. It does this by extracting the relevant entries from both the <code>NEWS.Debian</code> and <code>changelog[.Debian]</code> files, usually found in <code>/usr/share/doc/<em>package</em></code> in Debian package archives. <em>(not covered in this article)</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In practice, <code>.d</code> directories are privileged so that the configuration can be split into several files. Single file may not even exist on your machine and are often deprecated.</p>
</div>
<div class="paragraph">
<p><em>Further documentation</em>: <a href="https://wiki.debian.org/AptConfiguration">APT configuration</a>, <a href="https://wiki.debian.org/SecureApt">Secure APT</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now is the time to start looking at the code again. APT is written in C++. The entry point for any APT command is the file <code>cmdline/apt.cc</code> which contains a function <code>GetCommands()</code> that maps each command with a function defined in the directory <code>apt-private/</code>, which delegates to other functions in the main APT lib present in the directory <code>apt-pkg/</code> (i.e., cmdline/ &#8594; apt-private/ &#8594; apk-pkg/):</p>
</div>
<div class="listingblock">
<div class="title">cmdline/apt.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">static</span> std::vector&lt;aptDispatchWithHelp&gt; GetCommands()                        <span class="comment">/*{{{*/</span>
{
   <span class="keyword">return</span> {
      {<span class="string"><span class="delimiter">&quot;</span><span class="content">list</span><span class="delimiter">&quot;</span></span>, &amp;DoList, _(<span class="string"><span class="delimiter">&quot;</span><span class="content">list packages based on package names</span><span class="delimiter">&quot;</span></span>)},
      {<span class="string"><span class="delimiter">&quot;</span><span class="content">update</span><span class="delimiter">&quot;</span></span>, &amp;DoUpdate, _(<span class="string"><span class="delimiter">&quot;</span><span class="content">update list of available packages</span><span class="delimiter">&quot;</span></span>)},
      {<span class="string"><span class="delimiter">&quot;</span><span class="content">install</span><span class="delimiter">&quot;</span></span>, &amp;DoInstall, _(<span class="string"><span class="delimiter">&quot;</span><span class="content">install packages</span><span class="delimiter">&quot;</span></span>)},

      <span class="comment">// ...</span>

      {<span class="predefined-constant">nullptr</span>, <span class="predefined-constant">nullptr</span>, <span class="predefined-constant">nullptr</span>}
   };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before invoking the command function, APT simply initializes a few classes like <code>pkgSystem</code> to set the default configuration options.</p>
</div>
<div id="wynk-apt-configuration-options" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About APT Configuration Options</div>
<div class="paragraph">
<p>Unlike Dpkg, APT is highly configurable using the files <code>/etc/apt/apt.conf</code> and  <code>/etc/apt/apt.conf.d/</code>. The format is similar to some Linux tools like <code>bind</code> or <code>dhcp</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant$ cat /etc/apt/apt.conf.d/*
APT
{
  NeverAutoRemove
  {
    &quot;^firmware-linux.*&quot;;
    &quot;^linux-firmware$&quot;;
    &quot;^linux-image-[a-z0-9]*$&quot;;
    &quot;^linux-image-[a-z0-9]*-[a-z0-9]*$&quot;;
  };
};
DPkg::Pre-Install-Pkgs { &quot;/usr/bin/apt-listchanges --apt || test $? -lt 10&quot;; };
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The configuration file is organized in a tree organized into functional groups. For instance, <code>APT::Get::Assume-Yes</code> is an option within the <code>APT</code> tool group, for the <code>Get</code> tool. A new scope can be opened with curly braces, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>APT {
  Get {
    Assume-Yes &quot;true&quot;;
    Fix-Broken &quot;true&quot;;
  };
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can retrieve the full list of options using the command <code>apt-config</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# apt-config dump
APT &quot;&quot;;
APT::Architecture &quot;amd64&quot;;
APT::Build-Essential &quot;&quot;;
APT::Build-Essential:: &quot;build-essential&quot;;
APT::Install-Recommends &quot;1&quot;;
APT::Install-Suggests &quot;0&quot;;
APT::Sandbox &quot;&quot;;
APT::Sandbox::User &quot;_apt&quot;;
‚Ä¶ hundreds of other options ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inside the code, the configuration is accessible using the class <code>Configuration</code> (defined in <code>apt-pkg/contrib/configuration.h</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="preprocessor">#include</span> <span class="include">&lt;apt-pkg/configuration.h&gt;</span>

Configuration *_config = <span class="keyword">new</span> Configuration;

<span class="comment">// Example with a boolean option</span>
<span class="keyword">if</span> (_config-&gt;FindB(<span class="string"><span class="delimiter">&quot;</span><span class="content">pkgCacheFile::Generate</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">true</span>) == <span class="predefined-constant">false</span>) {}

<span class="comment">// Example with an integer option</span>
<span class="predefined-type">int</span> <span class="directive">const</span> Limit = _config-&gt;FindI(<span class="string"><span class="delimiter">&quot;</span><span class="content">Acquire::QueueHost::Limit</span><span class="delimiter">&quot;</span></span>,DEFAULT_HOST_LIMIT)</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Further documentation</em>: <a href="https://www.commandlinux.com/man-page/man5/apt.conf.5.html">man page</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="cmd-apt-update"><code>apt update</code></h3>
<div class="paragraph">
<p>Here is the entry point when running the command <code>apt update</code>:</p>
</div>
<div class="listingblock">
<div class="title">apt-private/private-update.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> DoUpdate(CommandLine &amp;CmdL)
{
   CacheFile Cache;

   <span class="comment">// Covered in step 1</span>
   <span class="comment">// Get the source list</span>
   <span class="keyword">if</span> (Cache.BuildSourceList() == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;
   pkgSourceList *List = Cache.GetSourceList();

   <span class="comment">// Covered in step 2</span>
   <span class="comment">// do the work</span>
   AcqTextStatus Stat(std::cout, ScreenWidth,_config-&gt;FindI(<span class="string"><span class="delimiter">&quot;</span><span class="content">quiet</span><span class="delimiter">&quot;</span></span>,<span class="integer">0</span>));
   ListUpdate(Stat, *List);

   <span class="comment">// Covered in step 3</span>
   <span class="comment">// Rebuild the cache.</span>
   pkgCacheFile::RemoveCaches();
   <span class="keyword">if</span> (Cache.BuildCaches(<span class="predefined-constant">false</span>) == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="comment">// Covered in step 4</span>
   <span class="comment">// show basic stats (if the user whishes)</span>
   <span class="keyword">if</span> (_config-&gt;FindB(<span class="string"><span class="delimiter">&quot;</span><span class="content">APT::Cmd::Show-Update-Stats</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">false</span>) == <span class="predefined-constant">true</span>)
   {
      <span class="predefined-type">int</span> upgradable = <span class="integer">0</span>;
      <span class="keyword">if</span> (Cache.Open(<span class="predefined-constant">false</span>) == <span class="predefined-constant">false</span>)
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;
      <span class="keyword">for</span> (pkgCache::PkgIterator I = Cache-&gt;PkgBegin(); I.end() != <span class="predefined-constant">true</span>; ++I)
      {
         pkgDepCache::StateCache &amp;state = Cache[I];
         <span class="keyword">if</span> (I-&gt;CurrentVer != <span class="integer">0</span> &amp;&amp; state.Upgradable() &amp;&amp; state.CandidateVer != <span class="predefined-constant">NULL</span>)
            upgradable++;
      }
      <span class="directive">const</span> <span class="predefined-type">char</span> *msg = P_(
         <span class="string"><span class="delimiter">&quot;</span><span class="content">%i package can be upgraded. Run 'apt list --upgradable' to see it.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>,
         <span class="string"><span class="delimiter">&quot;</span><span class="content">%i packages can be upgraded. Run 'apt list --upgradable' to see them.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>,
         upgradable);
      <span class="keyword">if</span> (upgradable == <span class="integer">0</span>)
         c1out &lt;&lt; _(<span class="string"><span class="delimiter">&quot;</span><span class="content">All packages are up to date.</span><span class="delimiter">&quot;</span></span>) &lt;&lt; std::endl;
      <span class="keyword">else</span>
         ioprintf(c1out, msg, upgradable);
   }

   <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command is divided in four steps that we will cover separately:</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="1">
<li>
<p><strong>Read the <code>sources.list</code> and <code>sources.list.d/*</code> files</strong>.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Get the source list</span>
<span class="keyword">if</span> (Cache.BuildSourceList() == <span class="predefined-constant">false</span>)
   <span class="keyword">return</span> <span class="predefined-constant">false</span>;
pkgSourceList *List = Cache.GetSourceList();</code></pre>
</div>
</div>
<div id="wynk-source-lists" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About Source Lists</div>
<div class="paragraph">
<p>Apt downloads packages from one or more software repositories, which are often remote servers. The precise list of repositories is determined by the file <code>/etc/apt/sources.list</code> and the ones inside <code>/etc/apt/sources.list.d</code>. Two formats are supported: one source per line (the widespread one-line style) or multiline stanzas defining one or more sources per stanza (the newer deb822 style).</p>
</div>
<div class="paragraph">
<p>Example using the old format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>deb http://us.archive.ubuntu.com/ubuntu focal main restricted
deb http://security.ubuntu.com/ubuntu focal-security main restricted
deb http://us.archive.ubuntu.com/ubuntu focal-updates main restricted</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example using the new format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="deb822">Types: deb
URIs: http://us.archive.ubuntu.com/ubuntu
Suites: focal focal-updates
Components: main restricted

Types: deb
URIs: http://security.ubuntu.com/ubuntu
Suites: focal-security
Components: main restricted</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will ignore the new DEB 822 format in this article.</p>
</div>
<div class="paragraph">
<p><em>Further documentation</em>: <a href="http://manpages.ubuntu.com/manpages/focal/man5/sources.list.5.html"><code>man 5 sources.list</code></a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The class <code>pkgSourceList</code> represents the list of configured sources and is defined like this:</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/sourcelist.h</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">class</span> <span class="class">pkgSourceList</span>
{
   <span class="directive">public</span>:

   <span class="keyword">typedef</span> std::vector&lt;metaIndex *&gt;::const_iterator const_iterator;

   <span class="directive">protected</span>:

   std::vector&lt;metaIndex *&gt; SrcList;

   <span class="directive">public</span>:

   <span class="directive">void</span> Reset();
   <span class="predefined-type">bool</span> ReadMainList();
   <span class="predefined-type">bool</span> Read(std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp;File);

   <span class="comment">// List accessors</span>
   <span class="directive">inline</span> const_iterator begin() <span class="directive">const</span> {<span class="keyword">return</span> SrcList.begin();};
   <span class="directive">inline</span> const_iterator end() <span class="directive">const</span> {<span class="keyword">return</span> SrcList.end();};
   <span class="directive">inline</span> <span class="predefined-type">unsigned</span> <span class="predefined-type">int</span> size() <span class="directive">const</span> {<span class="keyword">return</span> SrcList.size();};
   <span class="directive">inline</span> <span class="predefined-type">bool</span> empty() <span class="directive">const</span> {<span class="keyword">return</span> SrcList.empty();};

   <span class="predefined-type">bool</span> FindIndex(pkgCache::PkgFileIterator File,
                  pkgIndexFile *&amp;Found) <span class="directive">const</span>;
   <span class="predefined-type">bool</span> GetIndexes(pkgAcquire *Owner, <span class="predefined-type">bool</span> GetAll=<span class="predefined-constant">false</span>) <span class="directive">const</span>;

   pkgSourceList();
   <span class="directive">virtual</span> ~pkgSourceList();
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The list is initialized by the method <code>BuildSourceList()</code>:</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/cachefile.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> pkgCacheFile::BuildSourceList(OpProgress * <span class="comment">/*Progress*/</span>)
{
   std::unique_ptr&lt;pkgSourceList&gt; SrcList;
   SrcList.reset(<span class="keyword">new</span> pkgSourceList());
   <span class="keyword">if</span> (SrcList-&gt;ReadMainList() == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> _error-&gt;Error(_(<span class="string"><span class="delimiter">&quot;</span><span class="content">The list of sources could not be read.</span><span class="delimiter">&quot;</span></span>));
   <span class="local-variable">this</span>-&gt;SrcList = SrcList.release();
   <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>ReadMainList()</code> is used to read the sources.list files:</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/sourcelist.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> pkgSourceList::ReadMainList()
{
   Reset();
   <span class="predefined-type">string</span> Main = _config-&gt;FindFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dir::Etc::sourcelist</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">sources.list</span><span class="delimiter">&quot;</span></span>);
   <span class="predefined-type">string</span> Parts = _config-&gt;FindDir(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dir::Etc::sourceparts</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">sources.list.d</span><span class="delimiter">&quot;</span></span>);

   _error-&gt;PushToStack();
   <span class="keyword">if</span> (RealFileExists(Main) == <span class="predefined-constant">true</span>)
      ReadAppend(Main); <i class="conum" data-value="1"></i><b>(1)</b>
   <span class="keyword">if</span> (DirectoryExists(Parts) == <span class="predefined-constant">true</span>)
      ReadSourceDir(Parts); <i class="conum" data-value="1"></i><b>(1)</b>

   <span class="directive">auto</span> good = _error-&gt;PendingError() == <span class="predefined-constant">false</span>;
   _error-&gt;MergeWithStack();
   <span class="keyword">return</span> good;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Read*</code> methods parse the sources files. We omit the parsing code for brievity but both parsers pushes a new instance of <code>debReleaseIndex</code> in the <code>SrcList</code>.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p><strong>Fetch index files from each repository (<code>InRelease</code>, <code>Packages</code>, &#8230;&#8203;).</strong></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// do the work</span>
AcqTextStatus Stat(std::cout, ScreenWidth,_config-&gt;FindI(<span class="string"><span class="delimiter">&quot;</span><span class="content">quiet</span><span class="delimiter">&quot;</span></span>,<span class="integer">0</span>)); <i class="conum" data-value="1"></i><b>(1)</b>
ListUpdate(Stat, *List);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>AcqTextStatus</code> is used to report progress of the files downloading.</td>
</tr>
</table>
</div>
<div id="wynk-repositories" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About Repositories</div>
<div class="paragraph">
<p>A repository is a set of Debian binary or source packages organized in a special directory tree along various additional files&#8212;&#8203;checksums, signatures, translations, &#8230;&#8203; APT downloads some of these files to install a package on your system.</p>
</div>
<div class="paragraph">
<p>Ex: <code>deb <a href="https://deb.debian.org/debian" class="bare">https://deb.debian.org/debian</a> stable main contrib non-free</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>deb</code> is used for <strong>binary packages</strong>, <code>deb-src</code> for <strong>source packages</strong>.</p>
</li>
<li>
<p><code><a href="https://deb.debian.org/debian" class="bare">https://deb.debian.org/debian</a></code> specifies the root of the <strong>repository</strong>.</p>
</li>
<li>
<p><code>stable</code> is the distribution, which is commonly a <strong>suite</strong> (<code>stable</code>, <code>oldstable</code>, <code>testing</code>, <code>unstable</code>), which is an alias for a Debian <strong>codename</strong> (<code>wheezy</code>, <code>jessie</code>, <code>stretch</code>), which is based on Toy Story characters.</p>
</li>
<li>
<p><code>main contrib non-free</code> are the three <strong>component</strong> types and indicate the licensing terms of the software they contain.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is a preview of files tree for this repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>https://deb.debian.org/debian
‚îî‚îÄ‚îÄ dists/
    |‚îÄ‚îÄ Debian9.13/
    |‚îÄ‚îÄ Debian10.9/
    |   ‚îú‚îÄ‚îÄ ChangeLog
    |   ‚îú‚îÄ‚îÄ InRelease  # Same as Release + Release.gpg
    |   |              # (recommended to have only 1 file to download)
    |   ‚îú‚îÄ‚îÄ Release  # Lists the index files for this distribution
    |   |            # with their checkums
    |   ‚îú‚îÄ‚îÄ Release.gpg
    |   ‚îú‚îÄ‚îÄ contrib/
    |   ‚îú‚îÄ‚îÄ main/
    |   ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ binary-all/
    |   ‚îÇ¬†¬† |   |‚îÄ‚îÄ Packages.gz
    |   ‚îÇ¬†¬† |   |‚îÄ‚îÄ Packages.xz  # Several compression formats are accepted.
    |   |   |   |                # xz compression is required.
    |   ‚îÇ¬†¬† |   |‚îÄ‚îÄ Release  # Basic metadata about this directory.
    |   |   |   |            # Not comparable with the main Release file.
    |   ‚îÇ¬†¬† |‚îÄ‚îÄ binary-amd64/
    |   ‚îÇ¬†¬† |‚îÄ‚îÄ ...
    |   ‚îÇ¬†¬† |‚îÄ‚îÄ content-all.gz    # Index containing the list
    |   |   |‚îÄ‚îÄ content-amd64.gz  # of all files in package archives
    |   ‚îÇ¬†¬† |‚îÄ‚îÄ content-arm64.gz  # and their corresponding package archive.
    |   ‚îÇ¬†¬† |‚îÄ‚îÄ ...
    |   |   |‚îÄ‚îÄ i18n/  # Translations of Packages files
    |   |   ‚îî‚îÄ‚îÄ source/  # We ignore source packags in this article
    |   ‚îÇ¬†¬†     |‚îÄ‚îÄ  Release
    |   ‚îÇ¬†¬†     |‚îÄ‚îÄ  Sources.gz
    |   ‚îÇ¬†¬†     |‚îÄ‚îÄ  Sources.xz
    |   ‚îî‚îÄ‚îÄ non-free/
    |‚îÄ‚îÄ bullseye/  # Future Debian 11
    |‚îÄ‚îÄ buster/    # Symlink to Debian10.9
    |‚îÄ‚îÄ stable/    # Symlink to buster
    |‚îÄ‚îÄ stretch/   # Symlink to Debian9.13
    ‚îî‚îÄ‚îÄ testing/   # Symlink to bullseye</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now the explanations.</p>
</div>
<div class="paragraph">
<p>The root directory contains a directory <code>dists/</code> which in turn has a directory for each release and suite, the latter usually symlinks to the former. Each release subdirectory contains a signed <code>Release</code> file and a directory for each component. Inside these are directories for the different architectures, named <code>binary-&lt;arch&gt;</code> and <code>sources</code>. And in these are files <code>Packages</code> and <code>Sources</code> that are text files (in DEB 822 format and often compressed) containing the metadata of available packages.</p>
</div>
<div class="paragraph">
<p>Example of a <code>Packages</code> file:</p>
</div>
<div class="listingblock">
<div class="title"><a href="http://ftp.debian.org/debian/dists/Debian10.9/main/binary-amd64/Packages.gz" class="bare">http://ftp.debian.org/debian/dists/Debian10.9/main/binary-amd64/Packages.gz</a></div>
<div class="content">
<pre class="CodeRay highlight"><code># 57849 binary packages declarations like this:
Package: wget
Version: 1.20.1-1.1
Installed-Size: 3257
Maintainer: No√´l K√∂the &lt;noel@debian.org&gt;
Architecture: amd64
Depends: libc6 (&gt;= 2.28), libgnutls30 (&gt;= 3.6.6), libidn2-0 (&gt;= 0.6),
  libnettle6, libpcre2-8-0 (&gt;= 10.32), libpsl5 (&gt;= 0.16.0),
  libuuid1 (&gt;= 2.16), zlib1g (&gt;= 1:1.1.4)
Recommends: ca-certificates
Conflicts: wget-ssl
Description: retrieves files from the web
Multi-Arch: foreign
Homepage: https://www.gnu.org/software/wget/
Description-md5: 63a4a740bcd9e8e94bf661e4f1806e02
Tag: implemented-in::c, interface::commandline, network::client,
 protocol::ftp, protocol::http, protocol::ssl, role::program,
 suite::gnu, use::downloading, works-with::file
Section: web
Priority: standard
Filename: pool/main/w/wget/wget_1.20.1-1.1_amd64.deb
Size: 901956
MD5sum: a7e3faa711503bd9500650de8fc9835e
SHA256: 3821cee0d331cf75ee79daff716f9d320f758f9dff3eaa6d6cf12bae9ef14306

Package: libwget0
Source: wget2
Version: 1.99.1-2
Installed-Size: 387
Maintainer: No√´l K√∂the &lt;noel@debian.org&gt;
Architecture: amd64
Depends: libassuan0 (&gt;= 2.0.1), libbrotli1 (&gt;= 0.6.0), libbz2-1.0,
  libc6 (&gt;= 2.27), libgnutls30 (&gt;= 3.5.10), libgpg-error0 (&gt;= 1.14),
  libgpgme11 (&gt;= 1.1.2), libidn2-0 (&gt;= 0.6),
  liblzma5 (&gt;= 5.1.1alpha+20120614), libnghttp2-14 (&gt;= 1.3.0),
  libpcre2-8-0 (&gt;= 10.31), libpsl5 (&gt;= 0.16.0), zlib1g (&gt;= 1:1.1.4)
Description: Download library for files and recursive websites
Homepage: https://gitlab.com/gnuwget/wget2
Description-md5: 3cb4ed03cbc78579a7e509e41156a73f
Tag: role::shared-lib
Section: libs
Priority: optional
Filename: pool/main/w/wget2/libwget0_1.99.1-2_amd64.deb
Size: 146028
MD5sum: 944b2824ee264e1b0cc0f91c1a86e6e2
SHA256: 3bf97e4852e76dba5bf2261f4a949a445edda646d09d7d1175dccfdf77bdbc3f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example of a <code>Sources</code> file:</p>
</div>
<div class="listingblock">
<div class="title"><a href="http://ftp.debian.org/debian/dists/Debian10.9/main/source/Sources.gz" class="bare">http://ftp.debian.org/debian/dists/Debian10.9/main/source/Sources.gz</a></div>
<div class="content">
<pre class="CodeRay highlight"><code># 28489 source packages declarations like this:
Package: wget
Binary: wget, wget-udeb
Version: 1.20.1-1.1
Maintainer: No√´l K√∂the &lt;noel@debian.org&gt;
Build-Depends: debhelper (&gt;&gt; 11.0.0), pkg-config, gettext, texinfo,
  libidn2-0-dev, uuid-dev, libpsl-dev, libpcre2-dev,
  libgnutls28-dev (&gt;= 3.3.15-5), automake,
  libssl-dev (&gt;= 0.9.8k), zlib1g-dev, dh-strip-nondeterminism
Architecture: any
Standards-Version: 4.3.0
Format: 3.0 (quilt)
Files:
 7a84dd8efb09001dcb9af1576b35992c 2092 wget_1.20.1-1.1.dsc
 f6ebe9c7b375fc9832fb1b2028271fb7 4392853 wget_1.20.1.orig.tar.gz
 e0ed66f143f4d81dd0f27a8f01a9c5c8 60872 wget_1.20.1-1.1.debian.tar.xz
Checksums-Sha256:
 b19...261 2092 wget_1.20.1-1.1.dsc
 b78...1b3 4392853 wget_1.20.1.orig.tar.gz
 7ee...01e 60872 wget_1.20.1-1.1.debian.tar.xz
Homepage: https://www.gnu.org/software/wget/
Package-List:
 wget deb web standard arch=any
 wget-udeb udeb debian-installer optional arch=any
Directory: pool/main/w/wget
Priority: source
Section: web</code></pre>
</div>
</div>
<div class="paragraph">
<p>But still no <code>.deb</code> packages&#8230;&#8203; We need to move to another directory at the root of the repository to find them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>https://deb.debian.org/debian
‚îî‚îÄ‚îÄ dists/
    |‚îÄ‚îÄ contrib/
    |‚îÄ‚îÄ main/
    |   |‚îÄ‚îÄ 0/
    |   |‚îÄ‚îÄ 1/
    |   |‚îÄ‚îÄ ...
    |   |‚îÄ‚îÄ 9/
    |   |‚îÄ‚îÄ a/
    |   |‚îÄ‚îÄ ...
    |   |‚îÄ‚îÄ w/
    |       |‚îÄ‚îÄ ....
    |       ‚îî‚îÄ‚îÄ wget/
    |   |‚îÄ‚îÄ ...
    |   |‚îÄ‚îÄ z/
    |   |‚îÄ‚îÄ liba/
    |   |‚îÄ‚îÄ ...
    |   |‚îÄ‚îÄ libw/
    |   |   |‚îÄ‚îÄ wget_1.21-1+b1_amd64.deb
    |   |   |‚îÄ‚îÄ wget_1.21-1.debian.tar.xz
    |   |   |‚îÄ‚îÄ wget_1.21-1.dsc
    |   |   |‚îÄ‚îÄ wget_1.21-1_arm64.deb
    |   |   |‚îÄ‚îÄ wget_1.21.orig.tar.gz
    |   |   ‚îî‚îÄ‚îÄ wget_1.21.orig.tar.gz.asc
    |   |‚îÄ‚îÄ ...
    |   ‚îî‚îÄ‚îÄ libz/
    ‚îî‚îÄ‚îÄ non-free/</code></pre>
</div>
</div>
<div class="paragraph">
<p>The directory <code>pool/</code> has a directory for all the components, and in these are directories named <code>0</code>, &#8230;&#8203;, <code>9</code>, <code>a</code>, &#8230;&#8203; <code>z</code>, <code>liba</code>, &#8230;&#8203; , <code>libz</code>. And in these are directories named after the software packages they contain, and these directories finally contain the actual packages, i.e the <code>.deb</code> files.</p>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The "single letter" directories are just a trick to avoid having too many entries in a single directory which is what many systems traditionally have performance problems with.</p>
</li>
<li>
<p>The <code>pool/</code> directory avoid file duplication as binary and source packages are stored only once even if used by many releases under <code>dists/</code>.</p>
</li>
<li>
<p><code>Packages</code> and <code>Sources</code> index files are control files using a similar format as used in the first part of this article when creating our Debian archive package, with a special field <code>File</code> and <code>Directory</code> respectively, to link to the <code>pool/</code> directory.</p>
</li>
<li>
<p><code>Release</code> is an index file in the DEB822 format but containing only a single document whose field names refers to the repository&#8201;&#8212;&#8201;<code>Origin</code>, <code>Suite</code>, <code>Codename</code>, <code>Architectures</code> (plural), <code>Components</code>&#8201;&#8212;&#8201;and whose field <code>MD5Sum</code> contains the checksums for all files in this repository.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Further documentation</em>: <a href="https://wiki.debian.org/DebianRepository">Debian Repository</a> and the more complete <a href="https://wiki.debian.org/DebianRepository/Format">Repository Format</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is the function <code>ListUpdate</code> that actively downloads index files from the repositories:</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/update.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> ListUpdate(pkgAcquireStatus &amp;Stat,
                pkgSourceList &amp;List,
                <span class="predefined-type">int</span> PulseInterval)
{
   pkgAcquire Fetcher(&amp;Stat); <i class="conum" data-value="1"></i><b>(1)</b>
   <span class="keyword">if</span> (Fetcher.GetLock(_config-&gt;FindDir(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dir::State::Lists</span><span class="delimiter">&quot;</span></span>)) == <span class="predefined-constant">false</span>) <i class="conum" data-value="2"></i><b>(2)</b>
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="comment">// Populate it with the source selection</span>
   <span class="keyword">if</span> (List.GetIndexes(&amp;Fetcher) == <span class="predefined-constant">false</span>) <i class="conum" data-value="3"></i><b>(3)</b>
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="keyword">return</span> AcquireUpdate(Fetcher, PulseInterval, <span class="predefined-constant">true</span>); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The class <code>pkgAcquire</code> is the main component of the Acquire subsystem. APT is responsible to retrieve the packages from various sources, mainly remote repositories through HTTP and the Acquire system is responsible to fetch all <code>Item</code> required by APT in the most efficient way. It uses for example a pool of workers to speed up the downloading and is able to test for <a href="#wynk-apt-diffs">diffs files</a> before downloading full index files.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Most APT commands tries to acquire a lock to prevent two processes using the lib APT to run at the same time. The lock file is <code>/var/lib/apt/lists/lock</code> but other lock files exists for example to update the APT cache.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The method <code>GetIndexes()</code> creates new items to download <code>InRelease</code> files using the Acquire system.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The function <code>AcquireUpdate()</code> collects the results from the <code>Fetcher</code> and update the cache.</td>
</tr>
</table>
</div>
<div id="wynk-apt-diffs" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About APT Diffs</div>
<div class="paragraph">
<p><code>Packages</code> files (and also some other indices files present in a Debian repository) can be relatively large. For example, the compressed <code>Package.xz</code> file for the architecture <code>amd64</code> and the component <code>main</code> of the stable Debian repository weights 8 MB. These files are typically retrieved when you run the command <code>apt update</code> and APT provides a solution to this problem.</p>
</div>
<div class="paragraph">
<p>Indeed, a Debian repository can contains diff files (whose content are similar to the output of the command <code>diff</code>) along the standard files like <code>Packages</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>https://deb.debian.org/debian
‚îî‚îÄ‚îÄ dists/bullseye/main/binary-amd64
    |‚îÄ‚îÄ Packages.xz  7.8M
    ‚îî‚îÄ‚îÄ Packages.diff/
        |‚îÄ‚îÄ ... # The Debian official repository keeps ~30 days of diff files.
        |‚îÄ‚îÄ 2021-04-12-1400.57.gz        33
        |‚îÄ‚îÄ 2021-04-13-0200.48.gz        7.8K
        |‚îÄ‚îÄ 2021-04-13-1402.06.gz        637
        |‚îÄ‚îÄ 2021-04-13-2000.50.gz        660
        |‚îÄ‚îÄ 2021-04-14-0200.40.gz        2.7K
        |‚îÄ‚îÄ 2021-04-14-2000.54.gz        5.0K
        |‚îÄ‚îÄ 2021-04-15-0200.39.gz        3.8K
        ‚îî‚îÄ‚îÄ 2021-04-15-1400.39.gz        220</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>apt</code> command will try to retrieve these files and apply successive diffs on top of its local index file.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p><strong>Read the package lists and build the dependency tree.</strong></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// Rebuild the cache.</span>
pkgCacheFile::RemoveCaches();
<span class="keyword">if</span> (Cache.BuildCaches(<span class="predefined-constant">false</span>) == <span class="predefined-constant">false</span>)
   <span class="keyword">return</span> <span class="predefined-constant">false</span>;</code></pre>
</div>
</div>
<div id="wynk-dir-apt-cache" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About <code>/var/cache/apt/</code></div>
<div class="paragraph">
<p>This directory stores the latest version of the APT cache, used to speed up the execution of most commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ tree /var/cache/apt/
|-- archives  # Storage area for downloaded files
|   |-- lock      # Prevent two APT processes to update the cache simultaneously
|   |-- partial/  # Storage area for files in transit
|   |-- apt-transport-https_2.0.5_all.deb  # Debian downloaded archives
|   |__ ...                                # are kept for a configurable
|   |-- tree_1.8.0-1_amd64.deb             # retention.
|   `-- ...
|-- pkgcache.bin     # Binary files loaded directly in C++
|                    # using the mmap() system call.
`-- srcpkgcache.bin  # Contains the local index files
                     # and the archives file lists.
                     # Those are low-level files used
                     # for performance optimizations.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The APT Cache files under this directory (except the <code>lock</code> file) can be safely deleted using the command <code>apt clean</code> to reclaim disk space:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ sudo apt clean --dry-run
Del /var/cache/apt/archives/* /var/cache/apt/archives/partial/*
Del /var/lib/apt/lists/partial/*
Del /var/cache/apt/pkgcache.bin /var/cache/apt/srcpkgcache.bin</code></pre>
</div>
</div>
<div class="paragraph">
<p>APT is highly configurable and there are several options to clean the cache regurlarly, like after every package installation.</p>
</div>
</td>
</tr>
</table>
</div>
<div id="wynk-dir-apt-lib" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About <code>/var/lib/apt/</code></div>
<div class="paragraph">
<p>This directory stores the current state of APT, that is which packages have been installed, what is the latest version of retrieved index files used when updating the cache, etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ tree /var/lib/apt/
.
|-- daily_lock  # Used by the Systemd apt-daily.timer for housekeeping tasks.
|               # Runs /usr/lib/apt/apt.systemd.daily which clean the cache,
|               # update the repositories, create backups of extended_states...
|               # Not covered in this article.
|-- extended_states  # Extension to /var/lib/dpkg/status to store which
|                    # packages were installed manually or automatically
|                    # (i.e., as a dependency of another packages).
|                    # Useful to support autoremove of useless packages.
|-- listchanges.db  # Used by the command apt-listchanges
|                   # Not covered in this article.
|-- lists  # Local version of index files retrieved
|   |      # from repositories in sources.list
|   |-- deb.debian.org_debian_dists_buster-backports_InRelease
|   |-- deb.debian.org_debian_dists_buster-updates_InRelease
|   |-- deb.debian.org_debian_dists_buster_InRelease
|   |-- deb.debian.org_debian_dists_buster_main_binary-amd64_Packages
|   |-- deb.debian.org_debian_dists_buster_main_binary-amd64_Packages.diff_Index
|   |-- deb.debian.org_debian_dists_buster_main_i18n_Translation-en
|   |-- deb.debian.org_debian_dists_buster_main_i18n_Translation-en.diff_Index
|   |-- deb.debian.org_debian_dists_buster_main_source_Sources
|   |-- deb.debian.org_debian_dists_buster_main_source_Sources.diff_Index
|   |-- lock  # Same as /var/lib/dpkg/lock.
|   |         # Prevent two processes to use the lib APT at the same time
|   `-- partial/  # Storage area for index files in transit
|-- mirrors  # Used when using repository mirrors.
|   |        # Not covered in this article.
|   `-- partial
`-- periodic  # Empty files whose timestamps are updated
    |         # by the Systemd apt-daily.timer
    |         # to determine the last execution date.
    |         # Not covered in this article.
    |-- download-upgradeable-stamp
    |-- unattended-upgrades-stamp
    |-- update-stamp
    `-- upgrade-stamp</code></pre>
</div>
</div>
<div class="paragraph">
<p>This directory doesn&#8217;t have to be edited like <code>/etc/apt/</code> and doesn&#8217;t have to be cleaned like <code>/var/cache/apt/</code>. It can be safely ignored by the Apt user but we will still have to talk about it in this article.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The method <code>pkgCacheFile::BuildCaches()</code> calls the method <code>BuildSourceList()</code> we covered in the previous step, and then delegates to the method <code>pkgCacheGenerator::MakeStatusCache()</code> for the effective cache initialization:</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/pkgcachegen.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> pkgCacheGenerator::MakeStatusCache(pkgSourceList &amp;List,OpProgress *Progress,
                        MMap **OutMap,pkgCache **OutCache, <span class="predefined-type">bool</span>)
{
   std::vector&lt;pkgIndexFile *&gt; Files;
   <span class="keyword">if</span> (_system-&gt;AddStatusFiles(Files) == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="comment">// Decide if we can write to the files..</span>
   <span class="predefined-type">string</span> <span class="directive">const</span> CacheFileName = _config-&gt;FindFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dir::Cache::pkgcache</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
   <span class="predefined-type">string</span> <span class="directive">const</span> SrcCacheFileName = _config-&gt;FindFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dir::Cache::srcpkgcache</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>

   <span class="keyword">if</span> (Progress != <span class="predefined-constant">NULL</span>)
      Progress-&gt;OverallProgress(<span class="integer">0</span>,<span class="integer">1</span>,<span class="integer">1</span>,_(<span class="string"><span class="delimiter">&quot;</span><span class="content">Reading package lists</span><span class="delimiter">&quot;</span></span>));

   <span class="predefined-type">bool</span> pkgcache_fine = <span class="predefined-constant">false</span>;
   <span class="predefined-type">bool</span> srcpkgcache_fine = <span class="predefined-constant">false</span>;

   FileFd CacheFile;
   <span class="keyword">if</span> (CheckValidity(CacheFile, CacheFileName, List, Files.begin(), Files.end()) <i class="conum" data-value="2"></i><b>(2)</b>
   {
      pkgcache_fine = <span class="predefined-constant">true</span>;
      srcpkgcache_fine = <span class="predefined-constant">true</span>;
   }

   FileFd SrcCacheFile;
   <span class="keyword">if</span> (pkgcache_fine == <span class="predefined-constant">false</span>)
   {
      <span class="keyword">if</span> (CheckValidity(SrcCacheFile, SrcCacheFileName, List,
            Files.end(), Files.end()) == <span class="predefined-constant">true</span>) <i class="conum" data-value="2"></i><b>(2)</b>
      {
         srcpkgcache_fine = <span class="predefined-constant">true</span>;
      }
   }

   <span class="keyword">if</span> (srcpkgcache_fine == <span class="predefined-constant">true</span> &amp;&amp; pkgcache_fine == <span class="predefined-constant">true</span>)
   {
      <span class="keyword">if</span> (Progress != <span class="predefined-constant">NULL</span>)
         Progress-&gt;OverallProgress(<span class="integer">1</span>,<span class="integer">1</span>,<span class="integer">1</span>,_(<span class="string"><span class="delimiter">&quot;</span><span class="content">Reading package lists</span><span class="delimiter">&quot;</span></span>));
      <span class="keyword">return</span> <span class="predefined-constant">true</span>; <i class="conum" data-value="3"></i><b>(3)</b>
   }

   <span class="predefined-type">bool</span> Writeable = <span class="predefined-constant">false</span>;
   <span class="keyword">if</span> (srcpkgcache_fine == <span class="predefined-constant">false</span> || pkgcache_fine == <span class="predefined-constant">false</span>)
   {
      <span class="keyword">if</span> (CacheFileName.empty() == <span class="predefined-constant">false</span>)
         Writeable = access(flNotFile(CacheFileName).c_str(),W_OK) == <span class="integer">0</span>;
      <span class="keyword">else</span> <span class="keyword">if</span> (SrcCacheFileName.empty() == <span class="predefined-constant">false</span>)
         Writeable = access(flNotFile(SrcCacheFileName).c_str(),W_OK) == <span class="integer">0</span>;
   }

   <span class="comment">// At this point we know we need to construct something, so get storage ready</span>
   std::unique_ptr&lt;DynamicMMap&gt; Map(CreateDynamicMMap(<span class="predefined-constant">NULL</span>, <span class="integer">0</span>));

   std::unique_ptr&lt;pkgCacheGenerator&gt; Gen{<span class="predefined-constant">nullptr</span>};
   map_filesize_t CurrentSize = <span class="integer">0</span>;
   map_filesize_t TotalSize = <span class="integer">0</span>;

   <span class="keyword">if</span> (srcpkgcache_fine == <span class="predefined-constant">true</span> &amp;&amp; pkgcache_fine == <span class="predefined-constant">false</span>)
   {
      <span class="keyword">if</span> (loadBackMMapFromFile(Gen, Map, Progress, SrcCacheFile) == <span class="predefined-constant">false</span>)
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;
      srcpkgcache_fine = <span class="predefined-constant">true</span>;
      TotalSize += ComputeSize(<span class="predefined-constant">NULL</span>, Files.begin(), Files.end());
   }
   <span class="keyword">else</span> <span class="keyword">if</span> (srcpkgcache_fine == <span class="predefined-constant">false</span>)
   {
      Gen.reset(<span class="keyword">new</span> pkgCacheGenerator(Map.get(),Progress));
      <span class="keyword">if</span> (Gen-&gt;Start() == <span class="predefined-constant">false</span>)
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;

      TotalSize += ComputeSize(&amp;List, Files.begin(),Files.end());
      <span class="keyword">if</span> (BuildCache(*Gen, Progress, CurrentSize, TotalSize, &amp;List,
               Files.end(),Files.end()) == <span class="predefined-constant">false</span>)
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;

      <span class="keyword">if</span> (Writeable == <span class="predefined-constant">true</span> &amp;&amp; SrcCacheFileName.empty() == <span class="predefined-constant">false</span>)
         <span class="keyword">if</span> (writeBackMMapToFile(Gen.get(), Map.get(), SrcCacheFileName) == <span class="predefined-constant">false</span>)
            <span class="keyword">return</span> <span class="predefined-constant">false</span>;
   }

   <span class="keyword">if</span> (pkgcache_fine == <span class="predefined-constant">false</span>)
   {
      <span class="keyword">if</span> (BuildCache(*Gen, Progress, CurrentSize, TotalSize, <span class="predefined-constant">NULL</span>,
               Files.begin(), Files.end()) == <span class="predefined-constant">false</span>)
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;

      <span class="keyword">if</span> (Writeable == <span class="predefined-constant">true</span> &amp;&amp; CacheFileName.empty() == <span class="predefined-constant">false</span>)
         <span class="keyword">if</span> (writeBackMMapToFile(Gen.get(), Map.get(), CacheFileName) == <span class="predefined-constant">false</span>)
            <span class="keyword">return</span> <span class="predefined-constant">false</span>;
   }

   <span class="keyword">if</span> (OutMap != <span class="predefined-constant">nullptr</span>)
      *OutMap = Map.release();

   <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The cache is stored in <code>/var/cache/apt/pkgcache.bin</code> and <code>/var/cache/apt/srcpkgcache.bin</code>. There are binary files that are loaded in memory.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The method <code>CheckValidity</code> loads each cache file in memory and checks that they are up-to-date, by verifying that every required index files for every source exists.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If both cache files are correct, we can returns immediately. Otherwise, we need to rebuild from scratch the ones that are not fine.</td>
</tr>
</table>
</div>
<div id="wynk-apt-cache-files" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What You Need to Know About APT Cache Files</div>
<div class="paragraph">
<p>The APT Cache files are two binary files <code>/var/cache/apt/pkgcache.bin</code> and <code>/var/cache/apt/srcpkgcache.bin</code>.</p>
</div>
<div class="paragraph">
<p>Basically, these cache files contains all index files (<code>InRelease</code>, <code>Packages</code>, <code>Sources</code>, and <code>Translations</code>) retrieved from the APT repositories present in the list of sources (<code>/etc/apt/source.list</code> and <code>/etc/apt/source.list.d/</code>). The only difference between these two files is that the file <code>pkgcache.bin</code> appends also the content of <code>/var/lib/dpkg/status</code>.</p>
</div>
<div class="paragraph">
<p>Therefore, every time a new index file is retrieved by APT or when the Dpkg status file changes, the APT cache must be updated too.</p>
</div>
<div class="paragraph">
<p>The format of the cache files is optimized for the sole usage of APT and the main motivations is to speed up the loading of the cache in memory, and to reduce the memory usage. Therefore, the cache uses a binary format, which means you cannot read the files using your text editor. For example, <code>Header</code> is the first struct copied and starts like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>struct Header
{
   // Signature information
   unsigned long Signature; # 0x98FE76DC
   short MajorVersion;      # 0
   short MinorVersion;      # 2
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Field names are logically omitted and only values (sometimes converted to enums like the status string <code>installed</code> that becomes <code>6</code> in the binary file) are appended in successive order as confirmed by the command <code>xxd</code> which dump a file in hexadecimal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">$ xxd /var/cache/apt/pkgcache.bin  | head -1
00000000: dc76 fe98 1000 0000 a802 1c2c 4038 5818  .v.........,@8X.
#
#  long = 4 bytes, short = 2 bytes
#  amd64 = little endian
#
#        dc --------+
#        76 ------+ |
#        fe ----+ |         10 ---+           00 ---+
#        98 --+ | | |       00 -+ |           00 -+ |
#             | | | |           | |               | |
#  Signature: 98FE76DC   Minor: 0010 = 2   Major: 0000 = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>When APT is launched, these two files are loaded in memory using the <code>mmap()</code> system call and the rest of the code interacts with an instance of the class <code>pkgCache</code> and another of the class <code>pkgDepCache</code>. In fact, <code>pkgDepCache</code> wraps <code>pkgCache</code> to add state informations about the packages on the system so that <code>pkgCache</code> is mostly read-only.</p>
</div>
<div class="paragraph">
<p>The code to initialize these instances is not covered in the article. Check the files <code>apt-pkg/pkgcache.h</code>, <code>apt-pkg/cachefile.h</code> and <code>apt-pkg/pkgcachegen.h</code> if you are curious.</p>
</div>
<div class="paragraph">
<p><em>Further Documentation</em>: <a href="http://www.fifi.org/doc/libapt-pkg-doc/cache.html/ch1.html">APT Cache File Format</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We will not go deeper into the APT Cache code. We have already inspected the structure of the different index files (<code>InRelease</code>, <code>Packages</code>, &#8230;&#8203;) and we know that APT commands use <code>pkgCacheFile.GetPkgCache()</code> and <code>pkgCacheFile.GetDepCache()</code> to retrieve information from the cache.</p>
</div>
<div class="paragraph">
<p>What follows are annotated definitions to give you an idea of the kind of information present in the APT Cache:</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/pkgcache.h</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">class</span> <span class="class">pkgCache</span>
{
   <span class="directive">public</span>:

   <span class="keyword">struct</span> Header;  <span class="comment">// The size and count of each following properties</span>
                   <span class="comment">// required to jump to the index in the binary format.</span>

   <span class="keyword">struct</span> Group;  <span class="comment">// Packages with the same name form a group, so we have</span>
                  <span class="comment">// a simple way to access a package built</span>
                  <span class="comment">// for different architectures.</span>
                  <span class="comment">// Groups are also used to iterate over all binaries</span>
                  <span class="comment">// produced by a source package.</span>
   <span class="keyword">struct</span> Package;  <span class="comment">// A single package with all the available versions</span>
                    <span class="comment">// and the possible installed version.</span>
   <span class="keyword">struct</span> ReleaseFile;  <span class="comment">// Release index file.</span>
   <span class="keyword">struct</span> PackageFile;  <span class="comment">// Packages index file.</span>
   <span class="keyword">struct</span> Version;  <span class="comment">// A single version of a package with the list of</span>
                    <span class="comment">// dependencies and the list of files in this package.</span>
   <span class="keyword">struct</span> Description;  <span class="comment">// Translation of a single version of a package</span>
   <span class="keyword">struct</span> DependencyData;  <span class="comment">// Information for a single dependency</span>
                           <span class="comment">// (the version, the type, ...)</span>

   <span class="comment">// Iterators</span>
   <span class="keyword">class</span> <span class="class">GrpIterator</span>;
   <span class="keyword">class</span> <span class="class">PkgIterator</span>;
   <span class="keyword">class</span> <span class="class">VerIterator</span>;
   <span class="keyword">class</span> <span class="class">DescIterator</span>;
   <span class="keyword">class</span> <span class="class">DepIterator</span>;
   <span class="keyword">class</span> <span class="class">RlsFileIterator</span>;
   <span class="keyword">class</span> <span class="class">PkgFileIterator</span>;

   <span class="keyword">class</span> <span class="class">Namespace</span>;

   <span class="directive">public</span>:

   <span class="comment">// Pointers to the arrays of items</span>
   Header *HeaderP;
   Group *GrpP;
   Package *PkgP;
   DescFile *DescFileP;
   ReleaseFile *RlsFileP; <span class="comment">// All Release files used to build the cache</span>
   PackageFile *PkgFileP; <span class="comment">// All Packages files used to build the cache</span>
   Version *VerP;
   Description *DescP;
   DependencyData *DepDataP;

   <span class="comment">// Accessors</span>
   GrpIterator FindGrp(APT::StringView Name);
   PkgIterator FindPkg(APT::StringView Name);

   <span class="directive">inline</span> GrpIterator GrpBegin();
   <span class="directive">inline</span> GrpIterator GrpEnd();
   <span class="directive">inline</span> PkgIterator PkgBegin();
   <span class="directive">inline</span> PkgIterator PkgEnd();
   <span class="directive">inline</span> PkgFileIterator FileBegin();
   <span class="directive">inline</span> PkgFileIterator FileEnd();
   <span class="directive">inline</span> RlsFileIterator RlsFileBegin();
   <span class="directive">inline</span> RlsFileIterator RlsFileEnd();
};


<span class="keyword">struct</span> pkgCache::Package
{
   <span class="comment">/** \brief Architecture of the package */</span>
   map_stringitem_t Arch;
   <span class="comment">/** \brief List of versions sorted from highest version to lowest version */</span>
   map_pointer&lt;Version&gt; VersionList;
   <span class="comment">/** \brief index to the installed version */</span>
   map_pointer&lt;Version&gt; CurrentVer;
   <span class="comment">/** \brief index of the group this package belongs to */</span>
   map_pointer&lt;pkgCache::Group&gt; Group;

   <span class="comment">/** \brief List of all dependencies on this package */</span>
   map_pointer&lt;Dependency&gt; RevDepends;
   <span class="comment">/** \brief List of all &quot;packages&quot; this package provide */</span>
   map_pointer&lt;Provides&gt; ProvidesList;

   <span class="comment">// Install/Remove/Purge etc</span>
   <span class="comment">/** \brief state that the user wishes the package to be in */</span>
   map_number_t SelectedState;     <span class="comment">// What</span>
   <span class="comment">/** \brief installation state of the package */</span>
   map_number_t InstState;         <span class="comment">// Flags</span>
   <span class="comment">/** \brief indicates if the package is installed */</span>
   map_number_t CurrentState;      <span class="comment">// State</span>
};

<span class="keyword">struct</span> pkgCache::ReleaseFile
{
   <span class="comment">/** \brief physical disk file that this ReleaseFile represents */</span>
   map_stringitem_t FileName;
   map_stringitem_t Archive;
   map_stringitem_t Codename;
   map_stringitem_t Version;
   map_stringitem_t Origin;
   map_stringitem_t Label;
   <span class="comment">/** \brief The site the index file was fetched from */</span>
   map_stringitem_t Site;
};

<span class="keyword">struct</span> pkgCache::PackageFile
{
   <span class="comment">/** \brief physical disk file that this PackageFile represents */</span>
   map_stringitem_t FileName;
   <span class="comment">/** \brief the release information to keep record of which
    version belongs to which release e.g. for pinning. */</span>
   map_pointer&lt;ReleaseFile&gt; Release;

   map_stringitem_t Component;
   map_stringitem_t Architecture;
};

<span class="keyword">struct</span> pkgCache::Version
{
   <span class="comment">/** \brief complete version string */</span>
   map_stringitem_t VerStr;
   <span class="comment">/** \brief section this version is filled in */</span>
   map_stringitem_t Section;
   <span class="comment">/** \brief source package name this version comes from
      Always contains the name, even if it is the same as the binary name */</span>
   map_stringitem_t SourcePkgName;
   <span class="comment">/** \brief source version this version comes from
      Always contains the version string, even if it is the same as the binary version */</span>
   map_stringitem_t SourceVerStr;

   <span class="comment">/** \brief references all the PackageFile's that this version came from

       FileList can be used to determine what distribution(s) the Version
       applies to. If FileList is 0 then this is a blank version.
       The structure should also have a 0 in all other fields excluding
       pkgCache::Version::VerStr and Possibly pkgCache::Version::NextVer. */</span>
   map_pointer&lt;VerFile&gt; FileList;
   <span class="comment">/** \brief base of the dependency list */</span>
   map_pointer&lt;Dependency&gt; DependsList;
   <span class="comment">/** \brief links to the owning package

       This allows reverse dependencies to determine the package */</span>
   map_pointer&lt;Package&gt; ParentPkg;
   <span class="comment">/** \brief list of pkgCache::Provides */</span>
   map_pointer&lt;Provides&gt; ProvidesList;
};

<span class="keyword">struct</span> pkgCache::DependencyData
{
   <span class="comment">/** \brief string of the version the dependency is applied against */</span>
   map_stringitem_t Version;
   <span class="comment">/** \brief index of the package this depends applies to

       The generator will - if the package does not already exist -
       create a blank (no version records) package. */</span>
   map_pointer&lt;pkgCache::Package&gt; Package;

   <span class="comment">/** \brief Dependency type - Depends, Recommends, Conflicts, etc */</span>
   map_number_t Type;
   <span class="comment">/** \brief comparison operator specified on the depends line

       If the high bit is set then it is a logical OR with the previous record. */</span>
   map_flags_t CompareOp;
};

<span class="comment">// Other structs are omitted for brievity.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the definition of the class <code>pkgDepCache</code>:</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/depcache.h</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">class</span> <span class="class">pkgDepCache</span>
{
   <span class="directive">public</span>:

   <span class="keyword">enum</span> ModeList {ModeDelete = <span class="integer">0</span>, ModeKeep = <span class="integer">1</span>, ModeInstall = <span class="integer">2</span>, ModeGarbage = <span class="integer">3</span>};

   <span class="keyword">struct</span> StateCache
   {
      <span class="comment">// text versions of the two version fields</span>
      <span class="directive">const</span> <span class="predefined-type">char</span> *CandVersion;
      <span class="directive">const</span> <span class="predefined-type">char</span> *CurVersion;

      <span class="comment">// Pointer to the candidate install version.</span>
      Version *CandidateVer;

      <span class="comment">// Pointer to the install version.</span>
      Version *InstallVer;

      <span class="comment">// Various tree indicators</span>
      <span class="predefined-type">signed</span> <span class="predefined-type">char</span> Status;              <span class="comment">// -1,0,1,2</span>
      <span class="predefined-type">unsigned</span> <span class="predefined-type">char</span> Mode;              <span class="comment">// ModeList</span>

      <span class="comment">// Various test members for the current status of the package</span>
      <span class="directive">inline</span> <span class="predefined-type">bool</span> Keep() <span class="directive">const</span> {<span class="keyword">return</span> Mode == ModeKeep;};
      <span class="directive">inline</span> <span class="predefined-type">bool</span> Upgrade() <span class="directive">const</span> {<span class="keyword">return</span> Status &gt; <span class="integer">0</span> &amp;&amp; Mode == ModeInstall;};
      <span class="directive">inline</span> <span class="predefined-type">bool</span> Upgradable() <span class="directive">const</span> {<span class="keyword">return</span> Status &gt;= <span class="integer">1</span> &amp;&amp; CandidateVer != <span class="predefined-constant">NULL</span>;};
      <span class="directive">inline</span> <span class="predefined-type">bool</span> Downgrade() <span class="directive">const</span> {<span class="keyword">return</span> Status &lt; <span class="integer">0</span> &amp;&amp; Mode == ModeInstall;};
      <span class="directive">inline</span> <span class="predefined-type">bool</span> Held() <span class="directive">const</span> {<span class="keyword">return</span> Status != <span class="integer">0</span> &amp;&amp; Keep();};
      <span class="comment">// ...</span>
   };

   <span class="directive">protected</span>:

   <span class="comment">// State information</span>
   pkgCache *Cache;
   StateCache *PkgState;

   <span class="directive">public</span>:

   <span class="comment">// Accessors</span>
   <span class="directive">inline</span> StateCache &amp;<span class="directive">operator</span> [](PkgIterator <span class="directive">const</span> &amp;I) {<span class="keyword">return</span> PkgState[I-&gt;ID];};
   <span class="directive">inline</span> StateCache &amp;<span class="directive">operator</span> [](PkgIterator <span class="directive">const</span> &amp;I) <span class="directive">const</span> {<span class="keyword">return</span> PkgState[I-&gt;ID];};

   <span class="comment">// read persistent states</span>
   <span class="predefined-type">bool</span> readStateFile(OpProgress * <span class="directive">const</span> prog);
   <span class="predefined-type">bool</span> writeStateFile(OpProgress * <span class="directive">const</span> prog, <span class="predefined-type">bool</span> <span class="directive">const</span> InstalledOnly=<span class="predefined-constant">true</span>);

   <span class="predefined-type">bool</span> Init(OpProgress * <span class="directive">const</span> Prog);
   <span class="comment">// Generate all state information</span>
   <span class="directive">void</span> Update(OpProgress * <span class="directive">const</span> Prog = <span class="integer">0</span>);

   pkgDepCache(pkgCache * <span class="directive">const</span> Cache,Policy * <span class="directive">const</span> Plcy = <span class="integer">0</span>);
   <span class="directive">virtual</span> ~pkgDepCache();
};</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="4">
<li>
<p><strong>Display statistics about package upgrades.</strong></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This last step simply traverses the cache to extract the relevant information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">// show basic stats (if the user whishes)</span>
<span class="keyword">if</span> (_config-&gt;FindB(<span class="string"><span class="delimiter">&quot;</span><span class="content">APT::Cmd::Show-Update-Stats</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">false</span>) == <span class="predefined-constant">true</span>)
{
   <span class="predefined-type">int</span> upgradable = <span class="integer">0</span>;
   <span class="keyword">if</span> (Cache.Open(<span class="predefined-constant">false</span>) == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;
   <span class="keyword">for</span> (pkgCache::PkgIterator I = Cache-&gt;PkgBegin(); I.end() != <span class="predefined-constant">true</span>; ++I)
   {
      pkgDepCache::StateCache &amp;state = Cache[I]; <i class="conum" data-value="1"></i><b>(1)</b>
      <span class="keyword">if</span> (I-&gt;CurrentVer != <span class="integer">0</span> &amp;&amp; state.Upgradable() &amp;&amp; state.CandidateVer != <span class="predefined-constant">NULL</span>) <i class="conum" data-value="2"></i><b>(2)</b>
         upgradable++;
   }
   <span class="directive">const</span> <span class="predefined-type">char</span> *msg = P_(
      <span class="string"><span class="delimiter">&quot;</span><span class="content">%i package can be upgraded. Run 'apt list --upgradable' to see it.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>,
      <span class="string"><span class="delimiter">&quot;</span><span class="content">%i packages can be upgraded. Run 'apt list --upgradable' to see them.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>,
      upgradable); <i class="conum" data-value="3"></i><b>(3)</b>
   <span class="keyword">if</span> (upgradable == <span class="integer">0</span>)
      c1out &lt;&lt; _(<span class="string"><span class="delimiter">&quot;</span><span class="content">All packages are up to date.</span><span class="delimiter">&quot;</span></span>) &lt;&lt; std::endl;
   <span class="keyword">else</span>
      ioprintf(c1out, msg, upgradable);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The operator <code>[]</code> is overloaded in <code>pkgDepCache</code> to return <code>PkgState[I&#8594;ID]</code>, which is a struct <code>StateCache</code> containing the current installed and candidate versions.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The method <code>Upgradable()</code> reads the state to determine if a new candidate version is available and increments a counter.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The macro <code>P_</code> is defined by <code>define P_(msg,plural,n) (n == 1 ? msg : plural)</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That&#8217;s all for the command <code>apt update</code>. We will now cover other APT commands, reusing the knowledge we built about the APT cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="cmd-apt-list"><code>apt list</code></h3>
<div class="paragraph">
<p>Here is the code of the command <code>apt list</code>. This version omits optional arguments that are used to filter the list of results.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> DoList(CommandLine &amp;Cmd)
{
   pkgCacheFile CacheFile;
   pkgCache * <span class="directive">const</span> Cache = CacheFile.GetPkgCache(); <i class="conum" data-value="1"></i><b>(1)</b>
   pkgRecords records(CacheFile);

   std::<span class="predefined-type">string</span> format = <span class="string"><span class="delimiter">&quot;</span><span class="content">${color:highlight}${Package}</span><span class="delimiter">&quot;</span></span> +
      <span class="string"><span class="delimiter">&quot;</span><span class="content">${color:neutral}/${Origin} ${Version} </span><span class="delimiter">&quot;</span></span> +
      <span class="string"><span class="delimiter">&quot;</span><span class="content">${Architecture}${ }${apt:Status}</span><span class="delimiter">&quot;</span></span>; <i class="conum" data-value="2"></i><b>(2)</b>

   std::list&lt;pkgCache::VerIterator&gt; bag; <i class="conum" data-value="3"></i><b>(3)</b>

   GetVersionSet(CacheFile, &amp;bag);
   std::map&lt;std::<span class="predefined-type">string</span>, std::<span class="predefined-type">string</span>&gt; output_map;
   <span class="keyword">for</span> (std::list&lt;pkgCache::VerIterator&gt;::iterator V = bag.begin();
          V != bag.end(); ++V)
   {
      std::stringstream outs;
      ListSingleVersion(CacheFile, records, V, outs, format);
      output_map.insert(std::make_pair&lt;std::<span class="predefined-type">string</span>, std::<span class="predefined-type">string</span>&gt;(
               V.ParentPkg().FullName(), outs.str()));
   }

   <span class="comment">// output the map</span>
   std::map&lt;std::<span class="predefined-type">string</span>, std::<span class="predefined-type">string</span>&gt;::const_iterator K;
   <span class="keyword">for</span> (K = output_map.begin(); K != output_map.end(); ++K)
      std::cout &lt;&lt; (*K).second &lt;&lt; std::endl;

   <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>CacheFile.GetPkgCache()</code> delegates to the method <code>BuildCaches()</code> we covered in the previous section about <code>apt update</code>. This method is responsible to build the APT cache.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Concrete values will be replaced in the function <code>ListSingleVersion</code> by replacing <code>${Package}</code>, <code>${Origin}</code>, ‚Ä¶ by their real values.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The real implementation uses the type <code>LocalitySortedVersionSet</code> which is a list ordering packages based on their names in the <code>Translation</code> files of the user locale.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like for the <code>apt update</code> command, the code is simply using the information present in the APT cache. In this case, it happens in the function <code>GetVersionSet</code>:</p>
</div>
<div class="listingblock">
<div class="title">apt-private/private-cacheset.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> GetVersionSet(pkgCacheFile &amp;CacheFile,
                   std::list&lt;pkgCache::VerIterator&gt; versions)
{
   pkgCache * <span class="directive">const</span> Cache = CacheFile.GetPkgCache();
   pkgDepCache * <span class="directive">const</span> DepCache = CacheFile.GetDepCache();

   <span class="predefined-type">bool</span> <span class="directive">const</span> insertCurrentVer = _config-&gt;FindB(<span class="string"><span class="delimiter">&quot;</span><span class="content">APT::Cmd::Installed</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">false</span>);
   <span class="predefined-type">bool</span> <span class="directive">const</span> insertUpgradable = _config-&gt;FindB(<span class="string"><span class="delimiter">&quot;</span><span class="content">APT::Cmd::Upgradable</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">false</span>);

   <span class="keyword">for</span> (pkgCache::PkgIterator P = Cache-&gt;PkgBegin(); P.end() == <span class="predefined-constant">false</span>; ++P)
   {
      pkgDepCache::StateCache &amp;state = (*DepCache)[P];
      <span class="keyword">if</span> (insertCurrentVer == <span class="predefined-constant">true</span>) <i class="conum" data-value="1"></i><b>(1)</b>
      {
         <span class="keyword">if</span> (P-&gt;CurrentVer != <span class="integer">0</span>)
            versions-&gt;insert(P.CurrentVer());
      }
      <span class="keyword">else</span> <span class="keyword">if</span> (insertUpgradable == <span class="predefined-constant">true</span>) <i class="conum" data-value="2"></i><b>(2)</b>
      {
         <span class="keyword">if</span> (P.CurrentVer() &amp;&amp; state.Upgradable())
            versions-&gt;insert(CacheFile.GetPolicy()-&gt;GetCandidateVer(P));
      }
      <span class="keyword">else</span> <i class="conum" data-value="3"></i><b>(3)</b>
      {
         versions-&gt;insert(P.VersionList());
      }
   }
   <span class="keyword">if</span> (progress != <span class="predefined-constant">NULL</span>)
      progress-&gt;Done();
   <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The command <code>apt list --installed</code> searches for installed packages.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The command <code>apt list --upgradable</code> searches for installed packages that can be upgraded.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The command <code>apt list --all-versions</code> searches for all packages in the APT cache.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The packages are then formatted in the function <code>ListSingleVersion()</code>:</p>
</div>
<div class="listingblock">
<div class="title">apt-private/private-output.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> ListSingleVersion(pkgCacheFile &amp;CacheFile, pkgRecords &amp;records,        <span class="comment">/*{{{*/</span>
                       pkgCache::VerIterator <span class="directive">const</span> &amp;V, std::ostream &amp;out,
                       std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp;format)
{
   pkgCache::PkgIterator <span class="directive">const</span> P = V.ParentPkg();
   pkgDepCache * <span class="directive">const</span> DepCache = CacheFile.GetDepCache();
   pkgDepCache::StateCache <span class="directive">const</span> &amp;state = (*DepCache)[P];

   std::<span class="predefined-type">string</span> output = format; <i class="conum" data-value="1"></i><b>(1)</b>

   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${db::Status-Abbrev}</span><span class="delimiter">&quot;</span></span>,
                     GetFlagsStr(CacheFile, P));
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${Package}</span><span class="delimiter">&quot;</span></span>, P.Name());
   std::<span class="predefined-type">string</span> <span class="directive">const</span> ArchStr = GetArchitecture(CacheFile, P);
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${Architecture}</span><span class="delimiter">&quot;</span></span>, ArchStr);
   std::<span class="predefined-type">string</span> <span class="directive">const</span> InstalledVerStr = GetInstalledVersion(CacheFile, P);
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${installed:Version}</span><span class="delimiter">&quot;</span></span>, InstalledVerStr);
   std::<span class="predefined-type">string</span> <span class="directive">const</span> CandidateVerStr = GetCandidateVersion(CacheFile, P);
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${candidate:Version}</span><span class="delimiter">&quot;</span></span>, CandidateVerStr);
   std::<span class="predefined-type">string</span> <span class="directive">const</span> VersionStr = GetVersion(CacheFile, V);
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${Version}</span><span class="delimiter">&quot;</span></span>, VersionStr);
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${Origin}</span><span class="delimiter">&quot;</span></span>, GetArchiveSuite(CacheFile, V));

   std::<span class="predefined-type">string</span> StatusStr = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>; <i class="conum" data-value="2"></i><b>(2)</b>
   <span class="keyword">if</span> (P-&gt;CurrentVer != <span class="integer">0</span>)
   {
      <span class="keyword">if</span> (P.CurrentVer() == V)
      {
         <span class="keyword">if</span> (state.Upgradable() &amp;&amp; state.CandidateVer != <span class="predefined-constant">NULL</span>)
            strprintf(StatusStr, _(<span class="string"><span class="delimiter">&quot;</span><span class="content">[installed,upgradable to: %s]</span><span class="delimiter">&quot;</span></span>),
                  CandidateVerStr.c_str());
         <span class="keyword">else</span> <span class="keyword">if</span> (V.Downloadable() == <span class="predefined-constant">false</span>)
            StatusStr = _(<span class="string"><span class="delimiter">&quot;</span><span class="content">[installed,local]</span><span class="delimiter">&quot;</span></span>);
         <span class="keyword">else</span> <span class="keyword">if</span>(V.Automatic() == <span class="predefined-constant">true</span> &amp;&amp; state.Garbage == <span class="predefined-constant">true</span>)
            StatusStr = _(<span class="string"><span class="delimiter">&quot;</span><span class="content">[installed,auto-removable]</span><span class="delimiter">&quot;</span></span>);
         <span class="keyword">else</span> <span class="keyword">if</span> ((state.Flags &amp; pkgCache::Flag::Auto) == pkgCache::Flag::Auto)
            StatusStr = _(<span class="string"><span class="delimiter">&quot;</span><span class="content">[installed,automatic]</span><span class="delimiter">&quot;</span></span>);
         <span class="keyword">else</span>
            StatusStr = _(<span class="string"><span class="delimiter">&quot;</span><span class="content">[installed]</span><span class="delimiter">&quot;</span></span>);
      }
      <span class="keyword">else</span> <span class="keyword">if</span> (state.CandidateVer == V &amp;&amp; state.Upgradable())
         strprintf(StatusStr, _(<span class="string"><span class="delimiter">&quot;</span><span class="content">[upgradable from: %s]</span><span class="delimiter">&quot;</span></span>),
               InstalledVerStr.c_str());
   }
   <span class="keyword">else</span> <span class="keyword">if</span> (V.ParentPkg()-&gt;CurrentState == pkgCache::State::ConfigFiles)
      StatusStr = _(<span class="string"><span class="delimiter">&quot;</span><span class="content">[residual-config]</span><span class="delimiter">&quot;</span></span>);
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${apt:Status}</span><span class="delimiter">&quot;</span></span>, StatusStr);
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${color:highlight}</span><span class="delimiter">&quot;</span></span>,
                     _config-&gt;Find(<span class="string"><span class="delimiter">&quot;</span><span class="content">APT::Color::Highlight</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>));
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${color:neutral}</span><span class="delimiter">&quot;</span></span>,
                     _config-&gt;Find(<span class="string"><span class="delimiter">&quot;</span><span class="content">APT::Color::Neutral</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>));
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${Description}</span><span class="delimiter">&quot;</span></span>,
                     GetShortDescription(CacheFile, records, P));
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${LongDescription}</span><span class="delimiter">&quot;</span></span>,
                     GetLongDescription(CacheFile, records, P));
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${ }${ }</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">${ }</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="3"></i><b>(3)</b>
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${ }</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="3"></i><b>(3)</b>
   output = SubstVar(output, <span class="string"><span class="delimiter">&quot;</span><span class="content">${ }</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="3"></i><b>(3)</b>

   out &lt;&lt; output;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function ignores which fields are present in the output format and thus will try to replace all of them. If a field is missing, the replacement will do nothing.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The code uses the state information present in <code>depPkgCache</code> to determine if the package is installed, or upgradable, and so on.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The code ensures no remaining braces are left.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We will close the APT section by covering the most useful command.</p>
</div>
</div>
<div class="sect2">
<h3 id="cmd-apt-install"><code>apt install</code></h3>
<div class="paragraph">
<p>The entry point is the function <code>DoInstall()</code> which is called by various commands: <code>install</code>, <code>reinstall</code>, <code>remove</code>, <code>purge</code>, &#8230;&#8203; The code will be simplified to keep only the installation usage.</p>
</div>
<div class="listingblock">
<div class="title">apt-private/private-install.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> DoInstall(CommandLine &amp;CmdL)
{
   CacheFile Cache;

   <span class="comment">// Covered in step 1</span>
   <span class="keyword">if</span> (Cache.OpenForInstall() == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   std::set&lt;pkgCache::VerIterator&gt; verset;

   <span class="comment">// Covered in step 2</span>
   <span class="keyword">if</span> (!DoCacheManipulationFromCommandLine(CmdL, Cache, verset))
   {
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;
   }

   <span class="comment">// Covered in step 3</span>
   <span class="comment">/* Print out a list of packages that are going to be installed extra
      to what the user asked */</span>
   <span class="keyword">if</span> (Cache-&gt;InstCount() != verset.size()) <i class="conum" data-value="1"></i><b>(1)</b>
      std::list&lt;pkgCache::PkgIterator&gt; extras;
      <span class="keyword">for</span> (pkgCache::PkgIterator I = Cache-&gt;PkgBegin(); I.end() != <span class="predefined-constant">true</span>; ++I)
      {
        <span class="keyword">if</span> ((*Cache)[Pkg].Install() == <span class="predefined-constant">false</span>)
           <span class="keyword">continue</span>;
        pkgCache::VerIterator <span class="directive">const</span> Cand =
          (*Cache)[Pkg].CandidateVerIter(*Cache);
        <span class="keyword">if</span> (verset-&gt;find(Cand) == verset-&gt;end())
        {
           extra.insert(Pkg);
        }
      }
      ShowList(_(<span class="string"><span class="delimiter">&quot;</span><span class="content">The following additional packages will be installed:</span><span class="delimiter">&quot;</span></span>),
               extras);

   <span class="comment">/* Print out a list of suggested and recommended packages */</span>
   {
      std::list&lt;std::<span class="predefined-type">string</span>&gt; Recommends, Suggests, SingleRecommends, SingleSuggests;
      <span class="keyword">for</span> (<span class="directive">auto</span> <span class="directive">const</span> &amp;Pkg: pkgCache::PkgIterator(*Cache))
      {
         <span class="comment">/* Just look at the ones we want to install */</span>
         <span class="keyword">if</span> ((*Cache)[Pkg].Install() == <span class="predefined-constant">false</span>)
           <span class="keyword">continue</span>;

         <span class="comment">// get the recommends/suggests for the candidate ver</span>
         pkgCache::VerIterator CV = (*Cache)[Pkg].CandidateVerIter(*Cache);
         <span class="keyword">for</span> (pkgCache::DepIterator D = CV.DependsList(); D.end() == <span class="predefined-constant">false</span>; )
         {
            pkgCache::DepIterator Start;
            pkgCache::DepIterator End;
            D.GlobOr(Start, End); <span class="comment">// advances D</span>
            <span class="keyword">if</span> (Start-&gt;Type != pkgCache::Dep::Recommends &amp;&amp;
                Start-&gt;Type != pkgCache::Dep::Suggests)
               <span class="keyword">continue</span>;

            std::<span class="predefined-type">string</span> target;
            <span class="keyword">for</span> (pkgCache::DepIterator I = Start; I != D; ++I)
            {
               <span class="keyword">if</span> (target.empty() == <span class="predefined-constant">false</span>)
                  target.append(<span class="string"><span class="delimiter">&quot;</span><span class="content"> | </span><span class="delimiter">&quot;</span></span>);
               target.append(I.TargetPkg().FullName(<span class="predefined-constant">true</span>));
            }
            std::list&lt;std::<span class="predefined-type">string</span>&gt; &amp;Type =
                Start-&gt;Type == pkgCache::Dep::Recommends ?
                  Recommends :
                  Suggests;
            <span class="keyword">if</span> (std::find(Type.begin(), Type.end(), target) != Type.end())
               <span class="keyword">continue</span>;
            Type.push_back(target);
         }

      }
      ShowList(_(<span class="string"><span class="delimiter">&quot;</span><span class="content">Suggested packages:</span><span class="delimiter">&quot;</span></span>), Suggests);
      ShowList(_(<span class="string"><span class="delimiter">&quot;</span><span class="content">Recommended packages:</span><span class="delimiter">&quot;</span></span>), Recommends);
   }

   <span class="predefined-type">bool</span> result;

   <span class="comment">// Covered in step 4</span>
   result = InstallPackages(Cache, <span class="predefined-constant">false</span>);

   <span class="keyword">return</span> result;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The package problem resolver is launched during step 2 and can add new packages to install to satisfy dependencies. Therefore, the number of packages to install can be different from the number of packages specified in the command line.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="1">
<li>
<p><strong>Load the APT cache</strong></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The first step is without surprise to load the APT Cache using the method <code>pkgCacheFile::Open()</code> which reuses methods we have already discussed before.</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/cachefile.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> pkgCacheFile::Open(OpProgress *Progress)
{
   <span class="keyword">if</span> (BuildCaches(Progress) == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="keyword">if</span> (BuildPolicy(Progress) == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="keyword">if</span> (BuildDepCache(Progress) == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="keyword">if</span> (Progress != <span class="predefined-constant">NULL</span>)
      Progress-&gt;Done();
   <span class="keyword">if</span> (_error-&gt;PendingError() == <span class="predefined-constant">true</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p><strong>Determine the packages to install</strong></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Installing a package can also means uninstalling some other packages. Maybe the new version of a package stops using a dependency that was used only by this package and APT will try to autoremove it. The code is therefore a little more complicated.</p>
</div>
<div class="paragraph">
<p>For this step, we ignore most of these problems and focus on the installation of new packages with only new dependencies to install. The code will be adapted in consequence.</p>
</div>
<div class="paragraph">
<p>For every package to install, the code will update the state in <code>pkgDepCache</code> using the function <code>Cache&#8594;GetDepCache()&#8594;SetCandidateVersion()</code> and <code>Cache.MarkInstall()</code>. After that, the code executes the <code>pkgProblemResolver</code>. The goal is to fix broken packages, that is packages with missing or conflicting dependencies if the installation continues. The code is huge with more than 1000 lines of code. To give you an idea of the kind of constraints the resolver must satisfy, here are the relevant fields for a common package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Package: nginx-core
Description: nginx web/proxy server (standard version)
Version: 1.18.0-6+b1
Architecture: amd64
Replaces: nginx-full (&lt;&lt; 1.18.0-1)
Depends: libnginx-mod-http-geoip (= 1.18.0-6+b1), nginx-common (= 1.18.0-6),
  iproute2, libc6 (&gt;= 2.28), libcrypt1 (&gt;= 1:4.1.0), libpcre3,
  libssl1.1 (&gt;= 1.1.1), zlib1g (&gt;= 1:1.1.4)
Suggests: nginx-doc (= 1.18.0-6)
Conflicts: nginx-extras, nginx-light
Breaks: nginx (&lt;&lt; 1.4.5-1), nginx-full (&lt;&lt; 1.18.0-1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code documentation recognizes that the code has become complex and very sophisticated over time. Moreover, the resolver may even not be able to fix all broken packages. Packages may be missing and conflicts may still exist. Check the function <code>pkgProblemResolver::ResolveInternal()</code> defined in <code>apt-pkg/algorithms.cc</code> for more details.</p>
</div>
<div class="listingblock">
<div class="title">apt-private/private-install.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> DoCacheManipulationFromCommandLine(CommandLine &amp;CmdL, CacheFile &amp;Cache,
                                        std::set&lt;APT::VersionSet&gt; &amp;verset)
{
   std::unique_ptr&lt;pkgProblemResolver&gt; Fix(<span class="predefined-constant">nullptr</span>);
   Fix.reset(<span class="keyword">new</span> pkgProblemResolver(Cache));

   <span class="keyword">for</span> (<span class="directive">const</span> <span class="predefined-type">char</span> **I = CmdL.FileList + <span class="integer">1</span>; *I != <span class="integer">0</span>; ++I) { <i class="conum" data-value="1"></i><b>(1)</b>
      pkgCache::GrpIterator Grp = Cache.GetPkgCache()-&gt;FindGrp(pkg);
      verset.insert(Grp.FindPreferredPkg())
   }

   TryToInstall InstallAction(Cache, Fix.get());

   <span class="keyword">for</span> (<span class="predefined-type">unsigned</span> <span class="predefined-type">short</span> i = <span class="integer">0</span>; order[i] != <span class="integer">0</span>; ++i)
   {
      InstallAction = std::for_each(verset.begin(), verset.end(), InstallAction); <i class="conum" data-value="2"></i><b>(2)</b>
   }

   <span class="comment">// Call the scored problem resolver</span>
   OpTextProgress Progress(*_config);
   <span class="predefined-type">bool</span> resolver_fail = Fix-&gt;Resolve(<span class="predefined-constant">true</span>, &amp;Progress); <i class="conum" data-value="3"></i><b>(3)</b>

   <span class="keyword">if</span> (resolver_fail == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add one to <code>CmdL.FileList</code> to skip the <code>install</code> command name.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Mark this package version to be installed.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ensure the resolver fixed the broken packages before continuing the installation.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p><strong>Ask confirmation for additional packages to install</strong></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This step simply iterates over the package to install and inspects the calculated dependencies list to keep packages present in the fields <code>Recommends</code> and <code>Suggests</code>. The ‚Äúrecommended‚Äù dependencies are the most important and considerably improve the functionality offered by the package (these recommended packages are now installed by default by APT).</p>
</div>
<div class="paragraph">
<p>Here is an example of a package with recommended and suggested packages:</p>
</div>
<div class="listingblock">
<div class="title">/var/lib/apt/lists/deb.debian.org_debian_dists_buster_main_binary-amd64_Packages</div>
<div class="content">
<pre class="CodeRay highlight"><code>...
Package: ngraph-gtk
Version: 6.09.01-1
Maintainer: Hiroyuki Ito &lt;ZXB01226@nifty.com&gt;
Architecture: amd64
Depends: libc6 (&gt;= 2.4), libngraph0 (&gt;= 6.07.02)
Recommends: ngraph-gtk-addins, ngraph-gtk-doc
Suggests: fonts-liberation
Description: create scientific 2-dimensional graphs
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that dependencies of a package can also have recommended and suggested packages, and so on. Therefore, the final list displayed to the user is often pretty long:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# apt install ngraph-gtk
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following additional packages will be installed:
  adwaita-icon-theme at-spi2-core dbus-user-session dconf-gsettings-backend
  dconf-service fontconfig fontconfig-config fonts-dejavu-core glib-networking
  glib-networking-common glib-networking-services gsettings-desktop-schemas
  gtk-update-icon-cache hicolor-icon-theme libatk-bridge2.0-0 libatk1.0-0
  libatk1.0-data libatspi2.0-0 libavahi-client3 libavahi-common-data
  libavahi-common3 libcairo-gobject2 libcairo2 libcolord2 libcups2
  libdatrie1 libdconf1 libdeflate0 libepoxy0 libfontconfig1 libfribidi0
  libgdk-pixbuf-2.0-0 libgdk-pixbuf-xlib-2.0-0 libgdk-pixbuf2.0-0
  libgdk-pixbuf2.0-bin libgdk-pixbuf2.0-common libgraphite2-3 libgsl25
  libgslcblas0 libgtk-3-0 libgtk-3-bin libgtk-3-common libgtksourceview-4-0
  libgtksourceview-4-common libharfbuzz0b libjbig0 libjpeg62-turbo
  libjson-glib-1.0-0 libjson-glib-1.0-common liblcms2-2 libngraph0
  libpango-1.0-0 libpangocairo-1.0-0 libpangoft2-1.0-0 libpixman-1-0
  libproxy1v5 librest-0.7-0 librsvg2-2 librsvg2-common libsoup-gnome2.4-1
  libsoup2.4-1 libthai-data libthai0 libtiff5 libwayland-client0
  libwayland-cursor0 libwayland-egl1 libwebp6 libx11-6 libx11-data libxau6
  libxcb-render0 libxcb-shm0 libxcb1 libxcomposite1 libxcursor1 libxdamage1
  libxdmcp6 libxext6 libxfixes3 libxi6 libxinerama1 libxkbcommon0 libxrandr2
  libxrender1 libxtst6 ngraph-gtk-addins ngraph-gtk-addins-base
  ngraph-gtk-doc shared-mime-info x11-common xkb-data
Suggested packages:
  colord cups-common gsl-ref-psdoc | gsl-doc-pdf | gsl-doc-info |
  gsl-ref-html gvfs liblcms2-utils fonts-liberation librsvg2-bin
The following NEW packages will be installed:
  adwaita-icon-theme at-spi2-core dbus-user-session dconf-gsettings-backend
  dconf-service fontconfig fontconfig-config fonts-dejavu-core glib-networking
  glib-networking-common glib-networking-services gsettings-desktop-schemas
  gtk-update-icon-cache hicolor-icon-theme libatk-bridge2.0-0 libatk1.0-0
  libatk1.0-data libatspi2.0-0 libavahi-client3 libavahi-common-data
  libavahi-common3 libcairo-gobject2 libcairo2 libcolord2 libcups2 libdatrie1
  libdconf1 libdeflate0 libepoxy0 libfontconfig1 libfribidi0
  libgdk-pixbuf-2.0-0 libgdk-pixbuf-xlib-2.0-0 libgdk-pixbuf2.0-0
  libgdk-pixbuf2.0-bin libgdk-pixbuf2.0-common libgraphite2-3 libgsl25
  libgslcblas0 libgtk-3-0 libgtk-3-bin libgtk-3-common libgtksourceview-4-0
  libgtksourceview-4-common libharfbuzz0b libjbig0 libjpeg62-turbo
  libjson-glib-1.0-0 libjson-glib-1.0-common liblcms2-2 libngraph0
  libpango-1.0-0 libpangocairo-1.0-0 libpangoft2-1.0-0 libpixman-1-0
  libproxy1v5 librest-0.7-0 librsvg2-2 librsvg2-common libsoup-gnome2.4-1
  libsoup2.4-1 libthai-data libthai0 libtiff5 libwayland-client0
  libwayland-cursor0 libwayland-egl1 libwebp6 libx11-6 libx11-data libxau6
  libxcb-render0 libxcb-shm0 libxcb1 libxcomposite1 libxcursor1 libxdamage1
  libxdmcp6 libxext6 libxfixes3 libxi6 libxinerama1 libxkbcommon0 libxrandr2
  libxrender1 libxtst6 ngraph-gtk ngraph-gtk-addins ngraph-gtk-addins-base
  ngraph-gtk-doc shared-mime-info x11-common xkb-data
0 upgraded, 93 newly installed, 0 to remove and 11 not upgraded.
Need to get 38.5 MB of archives.
After this operation, 137 MB of additional disk space will be used.
Do you want to continue? [Y/n]</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can confirm from the previous output that recommended packages are well installed by default.</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="4">
<li>
<p><strong>Proceed to the installation</strong></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The last step is managed by the function <code>InstallPackages</code>:</p>
</div>
<div class="listingblock">
<div class="title">apt-private/private-install.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> InstallPackages(CacheFile &amp;Cache, <span class="predefined-type">bool</span> ShwKept, <span class="predefined-type">bool</span> Ask)
{
   <span class="comment">// Create the download object</span>
   aptAcquireWithTextStatus Fetcher;
   <span class="keyword">if</span> (Fetcher.GetLock(_config-&gt;FindDir(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dir::Cache::Archives</span><span class="delimiter">&quot;</span></span>)) == <span class="predefined-constant">false</span>) <i class="conum" data-value="1"></i><b>(1)</b>
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="comment">// Read the source list</span>
   <span class="keyword">if</span> (Cache.BuildSourceList() == <span class="predefined-constant">false</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;
   pkgSourceList * <span class="directive">const</span> List = Cache.GetSourceList();

   <span class="comment">// Create the text record parser</span>
   pkgRecords Recs(Cache);
   <span class="keyword">if</span> (_error-&gt;PendingError() == <span class="predefined-constant">true</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="comment">// Create the package manager and prepare to download</span>
   std::unique_ptr&lt;pkgPackageManager&gt; PM(_system-&gt;CreatePM(Cache)); <i class="conum" data-value="2"></i><b>(2)</b>
   <span class="keyword">if</span> (PM-&gt;GetArchives(&amp;Fetcher, List, &amp;Recs) == <span class="predefined-constant">false</span> ||
       _error-&gt;PendingError() == <span class="predefined-constant">true</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="directive">auto</span> <span class="directive">const</span> FetchBytes = Fetcher.FetchNeeded(); <i class="conum" data-value="3"></i><b>(3)</b>
   <span class="directive">auto</span> <span class="directive">const</span> FetchPBytes = Fetcher.PartialPresent(); <i class="conum" data-value="3"></i><b>(3)</b>

   <span class="comment">// Size delta</span>
   ioprintf(c1out,_(<span class="string"><span class="delimiter">&quot;</span><span class="content">After this operation, %sB of additional disk space </span><span class="delimiter">&quot;</span></span> +
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">will be used.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>),
            SizeToStr(Cache-&gt;UsrSize()).c_str());

   <span class="keyword">if</span> (_error-&gt;PendingError() == <span class="predefined-constant">true</span>)
      <span class="keyword">return</span> <span class="predefined-constant">false</span>;

   <span class="comment">// Prompt to continue</span>
   <span class="keyword">if</span> (Ask == <span class="predefined-constant">true</span> || Fail == <span class="predefined-constant">true</span>) <i class="conum" data-value="4"></i><b>(4)</b>
   {
      <span class="keyword">if</span> (_config-&gt;FindI(<span class="string"><span class="delimiter">&quot;</span><span class="content">quiet</span><span class="delimiter">&quot;</span></span>, <span class="integer">0</span>) &lt; <span class="integer">2</span> &amp;&amp;
            _config-&gt;FindB(<span class="string"><span class="delimiter">&quot;</span><span class="content">APT::Get::Assume-Yes</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">false</span>) == <span class="predefined-constant">false</span>)
      {
         <span class="keyword">if</span> (YnPrompt(_(<span class="string"><span class="delimiter">&quot;</span><span class="content">Do you want to continue?</span><span class="delimiter">&quot;</span></span>)) == <span class="predefined-constant">false</span>)
         {
            cout &lt;&lt; _(<span class="string"><span class="delimiter">&quot;</span><span class="content">Abort.</span><span class="delimiter">&quot;</span></span>) &lt;&lt; std::endl;
            exit(<span class="integer">1</span>);
         }
      }
   }

   <span class="comment">// Run it</span>
   <span class="predefined-type">bool</span> Failed = <span class="predefined-constant">false</span>;
   <span class="keyword">while</span> (<span class="integer">1</span>)
   {
      <span class="predefined-type">bool</span> Transient = <span class="predefined-constant">false</span>;
      <span class="keyword">if</span> (AcquireRun(Fetcher, <span class="integer">0</span>, &amp;Failed, &amp;Transient) == <span class="predefined-constant">false</span>)
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;

      <span class="keyword">if</span> (Failed == <span class="predefined-constant">true</span> &amp;&amp; _config-&gt;FindB(<span class="string"><span class="delimiter">&quot;</span><span class="content">APT::Get::Fix-Missing</span><span class="delimiter">&quot;</span></span>,<span class="predefined-constant">false</span>) == <span class="predefined-constant">false</span>)
         <span class="keyword">return</span> _error-&gt;Error(_(<span class="string"><span class="delimiter">&quot;</span><span class="content">Unable to fetch some archives, </span><span class="delimiter">&quot;</span></span> +
           <span class="string"><span class="delimiter">&quot;</span><span class="content">maybe run apt-get update or try with --fix-missing?</span><span class="delimiter">&quot;</span></span>));

      <span class="directive">auto</span> <span class="directive">const</span> progress = APT::Progress::PackageManagerProgressFactory();
      _system-&gt;UnLockInner(); <i class="conum" data-value="5"></i><b>(5)</b>
      pkgPackageManager::OrderResult <span class="directive">const</span> Res = PM-&gt;DoInstall(progress);
      <span class="keyword">delete</span> progress;

      <span class="keyword">if</span> (Res == pkgPackageManager::Failed || _error-&gt;PendingError() == <span class="predefined-constant">true</span>)
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;
      <span class="keyword">if</span> (Res == pkgPackageManager::Completed)
         <span class="keyword">break</span>;

      _system-&gt;LockInner();

      Fetcher.Shutdown();
      <span class="keyword">if</span> (PM-&gt;GetArchives(&amp;Fetcher, List, &amp;Recs) == <span class="predefined-constant">false</span>)
         <span class="keyword">return</span> <span class="predefined-constant">false</span>;

      Failed = <span class="predefined-constant">false</span>;
   }

   std::set&lt;std::<span class="predefined-type">string</span>&gt; <span class="directive">const</span> disappearedPkgs = PM-&gt;GetDisappearedPackages();
   <span class="keyword">if</span> (disappearedPkgs.empty() == <span class="predefined-constant">false</span>) <i class="conum" data-value="6"></i><b>(6)</b>
   {
      ShowList(c1out, P_(<span class="string"><span class="delimiter">&quot;</span><span class="content">The following package disappeared from your system as</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
               <span class="string"><span class="delimiter">&quot;</span><span class="content">all files have been overwritten by other packages:</span><span class="delimiter">&quot;</span></span>,
               <span class="string"><span class="delimiter">&quot;</span><span class="content">The following packages disappeared from your system as</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
               <span class="string"><span class="delimiter">&quot;</span><span class="content">all files have been overwritten by other packages:</span><span class="delimiter">&quot;</span></span>,
               disappearedPkgs.size()), disappearedPkgs,
            [](std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp;Pkg) { <span class="keyword">return</span> Pkg.empty() == <span class="predefined-constant">false</span>; },
            [](std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp;Pkg) { <span class="keyword">return</span> Pkg; },
            [](std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp;) { <span class="keyword">return</span> std::<span class="predefined-type">string</span>(); });
      cout &lt;&lt; _(<span class="string"><span class="delimiter">&quot;</span><span class="content">Note: This is done automatically and on purpose by dpkg.</span><span class="delimiter">&quot;</span></span>) &lt;&lt; std::endl;
   }

   <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>APT acquires a lock using the <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html"><code>fcntl()</code> system call</a> which is used to manipulate file descriptors. When called using the flag <code>F_SETLK</code>, the call returns -1 if the lock is already held by another process.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>APT supports multiple package managers but the default is the <code>dpkg</code> command. APT uses the class <code>debSystem</code> and the associated <code>pkgDPkgPM</code> to interact with the <code>dpkg</code> command.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The Acquire subsystem is reused to download the archives. Internally, the code keeps for every item to retrieve two fields <code>FileSize</code> and <code>PartialSize</code>, which are the size of the object to fetch and how much was already fetched. The methods <code>Fetcher.FetchNeeded()</code> and <code>Fetcher.FetchPartial()</code> iterates over the items to determine the total values.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>APT asks for confirmation before proceeding to the installation, except if you use options like <code>apt -y install</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Unlock Dpkg lock <code>/var/lib/dpkg/lock</code> to make sure the <code>dpkg</code> command can use it.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The package manager reads the <code>/var/lib/dpkg/status</code> to found out the packages that were removed because none of their files was referenced by another package.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The installation logic is implemented by the class <code>pkgDPkgPM</code>.</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/deb/dpkgpm.h</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">class</span> <span class="class">pkgDPkgPM</span> : <span class="directive">public</span> pkgPackageManager
{
   <span class="directive">protected</span>:

   <span class="comment">// progress reporting</span>
   <span class="keyword">struct</span> DpkgState
   {
      <span class="directive">const</span> <span class="predefined-type">char</span> *state;     <span class="comment">// the dpkg state (e.g. &quot;unpack&quot;)</span>
      <span class="directive">const</span> <span class="predefined-type">char</span> *str;       <span class="comment">// the human readable translation of the state</span>
   };

   <span class="comment">// the dpkg states that the pkg will run through, the string is</span>
   <span class="comment">// the package, the vector contains the dpkg states that the package</span>
   <span class="comment">// will go through</span>
   std::map&lt;std::<span class="predefined-type">string</span>,std::vector&lt;<span class="keyword">struct</span> DpkgState&gt; &gt; PackageOps;
   <span class="comment">// the dpkg states that are already done; the string is the package</span>
   <span class="comment">// the int is the state that is already done (e.g. a package that is</span>
   <span class="comment">// going to be install is already in state &quot;half-installed&quot;)</span>
   std::map&lt;std::<span class="predefined-type">string</span>,<span class="predefined-type">unsigned</span> <span class="predefined-type">int</span>&gt; PackageOpsDone;

   <span class="comment">// progress reporting</span>
   <span class="predefined-type">unsigned</span> <span class="predefined-type">int</span> PackagesDone;
   <span class="predefined-type">unsigned</span> <span class="predefined-type">int</span> PackagesTotal;

   <span class="directive">public</span>:
   <span class="keyword">struct</span> Item
   {
      <span class="keyword">enum</span> Ops {Install, Configure, Remove, Purge, ConfigurePending, TriggersPending,
         RemovePending, PurgePending } Op;
      std::<span class="predefined-type">string</span> File;
      PkgIterator Pkg;
      Item(Ops Op,PkgIterator Pkg,std::<span class="predefined-type">string</span> File = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>) : Op(Op),
            File(File), Pkg(Pkg) {};
      Item() {};
   };
   <span class="directive">protected</span>:
   std::vector&lt;Item&gt; List; <i class="conum" data-value="1"></i><b>(1)</b>

   <span class="directive">virtual</span> <span class="predefined-type">bool</span> Install(PkgIterator Pkg,std::<span class="predefined-type">string</span> File) <span class="directive">override</span>; <i class="conum" data-value="2"></i><b>(2)</b>
   <span class="directive">virtual</span> <span class="predefined-type">bool</span> Configure(PkgIterator Pkg) <span class="directive">override</span>;
   <span class="directive">virtual</span> <span class="predefined-type">bool</span> Remove(PkgIterator Pkg,<span class="predefined-type">bool</span> Purge = <span class="predefined-constant">false</span>) <span class="directive">override</span>;

   <span class="directive">virtual</span> <span class="predefined-type">bool</span> Go(APT::Progress::PackageManager *progress) <span class="directive">override</span>; <i class="conum" data-value="3"></i><b>(3)</b>

   <span class="directive">virtual</span> <span class="directive">void</span> Reset() <span class="directive">override</span>;

   <span class="directive">public</span>:

   <span class="directive">explicit</span> pkgDPkgPM(pkgDepCache *Cache);
   <span class="directive">virtual</span> ~pkgDPkgPM();

   APT_HIDDEN <span class="directive">static</span> <span class="predefined-type">bool</span> ExpandPendingCalls(std::vector&lt;Item&gt; &amp;List, pkgDepCache &amp;Cache);
};</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The package manager keeps a list of actions to perform.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The method <code>Install</code> simply appends a new item in <code>List</code> of type <code>Install</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The method <code>Go</code> reads the list of actions and execute them.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The only remaining code is the <code>dpkg</code> command execution:</p>
</div>
<div class="listingblock">
<div class="title">apt-pkg/deb/dpkgpm.cc</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="predefined-type">bool</span> pkgDPkgPM::Go(APT::Progress::PackageManager *progress)
{
   ...

   <span class="comment">// Generate the base argument list for dpkg</span>
   std::vector&lt;<span class="directive">const</span> <span class="predefined-type">char</span> *&gt; Args = { <span class="string"><span class="delimiter">&quot;</span><span class="content">dpkg</span><span class="delimiter">&quot;</span></span> };

   <span class="comment">// this loop is runs once per dpkg operation</span>
   vector&lt;Item&gt;::const_iterator I = List.cbegin();
   <span class="keyword">while</span> (I != List.end())
   {

      <span class="predefined-type">int</span> fd[<span class="integer">2</span>];
      <span class="keyword">if</span> (pipe(fd) != <span class="integer">0</span>)
         <span class="keyword">return</span> _error-&gt;Errno(<span class="string"><span class="delimiter">&quot;</span><span class="content">pipe</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to create IPC pipe to dpkg</span><span class="delimiter">&quot;</span></span>);

      ADDARGC(<span class="string"><span class="delimiter">&quot;</span><span class="content">--status-fd</span><span class="delimiter">&quot;</span></span>);
      <span class="predefined-type">char</span> status_fd_buf[<span class="integer">20</span>];
      snprintf(status_fd_buf,<span class="keyword">sizeof</span>(status_fd_buf),<span class="string"><span class="delimiter">&quot;</span><span class="content">%i</span><span class="delimiter">&quot;</span></span>, fd[<span class="integer">1</span>]);
      ADDARG(status_fd_buf);
      <span class="predefined-type">unsigned</span> <span class="predefined-type">long</span> <span class="directive">const</span> Op = I-&gt;Op;

      <span class="keyword">switch</span> (I-&gt;Op)
      {
         <span class="comment">// Skip other operations</span>

         <span class="keyword">case</span> Item::Install:
         ADDARGC(<span class="string"><span class="delimiter">&quot;</span><span class="content">--unpack</span><span class="delimiter">&quot;</span></span>);
         ADDARGC(<span class="string"><span class="delimiter">&quot;</span><span class="content">--auto-deconfigure</span><span class="delimiter">&quot;</span></span>);
         <span class="keyword">break</span>;
      }

      <span class="comment">// Write in the file or package name</span>
      <span class="keyword">if</span> (I-&gt;Op == Item::Install)
      {
         <span class="keyword">if</span> (I-&gt;File[<span class="integer">0</span>] != <span class="char">'/'</span>)
               <span class="keyword">return</span> _error-&gt;Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Internal Error, </span><span class="delimiter">&quot;</span></span> +
               <span class="string"><span class="delimiter">&quot;</span><span class="content">Pathname to install is not absolute '%s'</span><span class="delimiter">&quot;</span></span>, I-&gt;File.c_str());
            Args.push_back(I-&gt;File.c_str());
      }

      pid_t Child = ExecFork(fd[<span class="integer">1</span>]); <i class="conum" data-value="1"></i><b>(1)</b>
      <span class="keyword">if</span> (Child == <span class="integer">0</span>)
      {
         <span class="comment">// This is the child</span>
         close(fd[<span class="integer">0</span>]); <span class="comment">// close the read end of the pipe</span>

         debSystem::DpkgChrootDirectory();

         <span class="keyword">if</span> (chdir(_config-&gt;FindDir(<span class="string"><span class="delimiter">&quot;</span><span class="content">DPkg::Run-Directory</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>).c_str()) != <span class="integer">0</span>)
            _exit(<span class="integer">100</span>);

         execvp(Args[<span class="integer">0</span>], (<span class="predefined-type">char</span>**) &amp;Args[<span class="integer">0</span>]); <i class="conum" data-value="1"></i><b>(1)</b>
         cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not exec dpkg!</span><span class="delimiter">&quot;</span></span> &lt;&lt; endl;
         _exit(<span class="integer">100</span>);
      }

      <span class="comment">// we read from dpkg here</span>
      <span class="predefined-type">int</span> <span class="directive">const</span> _dpkgin = fd[<span class="integer">0</span>];
      close(fd[<span class="integer">1</span>]); <span class="comment">// close the write end of the pipe</span>

      <span class="comment">// the result of the waitpid call</span>
      <span class="predefined-type">int</span> Status = <span class="integer">0</span>;
      <span class="predefined-type">int</span> res;
      <span class="predefined-type">bool</span> waitpid_failure = <span class="predefined-constant">false</span>;
      <span class="predefined-type">bool</span> dpkg_finished = <span class="predefined-constant">false</span>;
      <span class="keyword">do</span>
      {
         <span class="keyword">if</span> (dpkg_finished == <span class="predefined-constant">false</span>)
         {
            <span class="keyword">if</span> ((res = waitpid(Child, &amp;Status, WNOHANG)) == Child) <i class="conum" data-value="1"></i><b>(1)</b>
               dpkg_finished = <span class="predefined-constant">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; <span class="integer">0</span>)
            {
               <span class="comment">// error handling, waitpid returned -1</span>
               <span class="keyword">if</span> (errno == EINTR)
                  <span class="keyword">continue</span>;
               waitpid_failure = <span class="predefined-constant">true</span>;
               <span class="keyword">break</span>;
            }
         }
         <span class="keyword">if</span> (dpkg_finished)
            <span class="keyword">break</span>;

      } <span class="keyword">while</span> (<span class="predefined-constant">true</span>);

      <span class="keyword">if</span> (waitpid_failure == <span class="predefined-constant">true</span>)
      {
         strprintf(d-&gt;dpkg_error, <span class="string"><span class="delimiter">&quot;</span><span class="content">Sub-process %s couldn't be waited for.</span><span class="delimiter">&quot;</span></span>,
                   Args[<span class="integer">0</span>]);
         _error-&gt;Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">%s</span><span class="delimiter">&quot;</span></span>, d-&gt;dpkg_error.c_str());
         <span class="keyword">break</span>;
      }

      ...
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The code is a classic example of Linux programming. The code uses the system calls <code>fork()</code>, <code>exec()</code>, and <code>wait()</code> to delegate to the command <code>dpkg</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After the <code>dpkg</code> command has run, the APT cache will still have to be updated as the state of some packages has been updated. There is nothing really new and we can stop our inspection of the APT code.</p>
</div>
</div>
<div class="sect2">
<h3 id="sect-part3-go">Case Study</h3>
<div class="paragraph">
<p>Like for other parts, we will write a minimal version of the command <code>apt install</code> in Go. We will not bother with a cache and simply read the Debian repositories systematically.</p>
</div>
<div class="paragraph">
<p>To test our program, we need a basic package so that we can focus on the core logic of the APT installation process without having to support advanced logics. We will use a new version of our package <code>hello</code> (the code is available in the <a href="https://github.com/julien-sobczak/linux-packages-under-the-hood">companion GitHub repository</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# tree /vagrant/hello/3.1-1/
3.1-1/
|-- DEBIAN
|   `-- control
`-- usr
    `-- bin
        `-- hello

vagrant# cat /vagrant/hello/3.1-1/DEBIAN/control
Package: hello
Version: 3.1-1
Section: base
Priority: optional
Architecture: amd64
Maintainer: Julien Sobczak
Description: Say Hello
Depends: cowsay <i class="conum" data-value="1"></i><b>(1)</b>

vagrant# cat /vagrant/hello/3.1-1/usr/bin/hello
#!/bin/bash
echo &quot;hello world&quot; | /usr/games/cowsay <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare a required dependency available in the standard Debian repository.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use the binary installed by this dependency.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To build the new package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# $ dpkg --build 3.1-1 hello_3.1-1_amd64.deb <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We use the command <code>dpkg</code> but we could also have used our Go version created in the first part.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Example of installation using APT:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">vagrant# apt install /vagrant/hello/hello_3.1-1_amd64.deb
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following additional packages will be installed:
  cowsay
Suggested packages:
  filters cowsay-off
The following NEW packages will be installed:
  cowsay hello
0 upgraded, 2 newly installed, 0 to remove and 11 not upgraded.
After this operation, 94.2 kB of additional disk space will be used.
Do you want to continue? [Y/n] Y

Get:1 /vagrant/hello/hello_3.1-1_amd64.deb hello amd64 3.1-1 [20.7 kB]
Get:2 http://deb.debian.org/debian bullseye/main amd64 cowsay all 3.03+dfsg2-8 [21.4 kB]
Fetched 21.4 kB in 0s (66.6 kB/s)
Selecting previously unselected package cowsay.
(Reading database ... 34384 files and directories currently installed.)
Preparing to unpack .../cowsay_3.03+dfsg2-8_all.deb ...
Unpacking cowsay (3.03+dfsg2-8) ...
Selecting previously unselected package hello.
Preparing to unpack .../hello/hello_3.1-1_amd64.deb ...
preinst says hello
Unpacking hello (3.1-1) ...
Setting up cowsay (3.03+dfsg2-8) ...
Setting up hello (3.1-1) ...
postinst says hello
Processing triggers for man-db (2.9.4-2) ...

vagrant# hello
 _____________
&lt; hello world &gt;
 -------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</code></pre>
</div>
</div>
<div class="paragraph">
<p>The challenge is to install the same package using a basic Go program. We will reuse the <code>dpkg</code> version we wrote in Go.</p>
</div>
<div class="paragraph">
<p>Here is the code:</p>
</div>
<div class="listingblock">
<div class="title">main.go</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="go"><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string"><span class="delimiter">&quot;</span><span class="content">bufio</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">bytes</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">crypto/md5</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">crypto/sha256</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">fmt</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">io</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">io/ioutil</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">net/http</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">os</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">os/exec</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">path/filepath</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">regexp</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">strings</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">sync</span><span class="delimiter">&quot;</span></span>

    <span class="string"><span class="delimiter">&quot;</span><span class="content">github.com/julien-sobczak/deb822</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">github.com/ulikunitz/xz</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">golang.org/x/crypto/openpgp</span><span class="delimiter">&quot;</span></span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">golang.org/x/crypto/openpgp/clearsign</span><span class="delimiter">&quot;</span></span>
)

<span class="comment">// The command `apt install` requires more code</span>
<span class="comment">// than our previous implementation of the command `dpkg`.</span>
<span class="comment">// We will introduce the different components successively.</span>

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">//</span>
<span class="comment">// The Acquire subsystem</span>
<span class="comment">//</span>

<span class="comment">// Apt accepts package names and needs to retrieve their archives</span>
<span class="comment">// from repositories, commonly using HTTP.</span>
<span class="comment">// The pkgAcquire struct downloads the various required files</span>
<span class="comment">// using a pool of worker to process each item to download.</span>
<span class="comment">// Like the real implementation, this system is not a generic downloader</span>
<span class="comment">// but contains some Apt logic.</span>

<span class="keyword">type</span> pkgAcquire <span class="keyword">struct</span> {
    <span class="comment">// The downloaded items are used to populate the Apt cache</span>
    cacheFile *CacheFile

    <span class="comment">// The items still not finished.</span>
    pendingJobs <span class="predefined-type">int</span>
    jobs        <span class="keyword">chan</span> Item
    results     <span class="keyword">chan</span> <span class="predefined-type">error</span>
    <span class="comment">// Workers are run in goroutines and push new items.</span>
    jobsMutex sync.Mutex
}

<span class="comment">// There are different types of files to retrieve from an Apt repository:</span>
<span class="comment">// - `InRelease`: the metadata about the repository.</span>
<span class="comment">// - `Packages`: the list of packages present in the repository.</span>
<span class="comment">// - `.deb` files: the archives to install using `dpkg`.</span>
<span class="comment">// Each item is accessible from an URI, must be stored locally, and required</span>
<span class="comment">// some postprocessing like checking the integrity of the files to prevent</span>
<span class="comment">// MITM attacks.</span>

<span class="keyword">type</span> Item <span class="keyword">interface</span> {
    <span class="comment">// DownloadURI returns the URI to retrieve the item.</span>
    DownloadURI() <span class="predefined-type">string</span>

    <span class="comment">// DestFile returns the path where the file</span>
    <span class="comment">// represented by the URI must be written.</span>
    DestFile(uri <span class="predefined-type">string</span>) <span class="predefined-type">string</span>

    <span class="comment">// Done is called when the file has been downloaded.</span>
    <span class="comment">// This function updates the cache with the retrieved item</span>
    <span class="comment">// and can trigger new downloads.</span>
    Done(c *CacheFile, a *pkgAcquire) <span class="predefined-type">error</span>
}

<span class="comment">// We will detail each type after the implementation of pkgAcquire.</span>

<span class="comment">// NewPkgAcquire initializes the Acquire system.</span>
<span class="keyword">func</span> NewPkgAcquire(c *CacheFile) *pkgAcquire {
    a := &amp;pkgAcquire{
        cacheFile:   c,
        pendingJobs: <span class="integer">0</span>,
        jobs:        <span class="predefined">make</span>(<span class="keyword">chan</span> Item, <span class="integer">1000</span>),
        results:     <span class="predefined">make</span>(<span class="keyword">chan</span> <span class="predefined-type">error</span>, <span class="integer">1000</span>),
    }

    <span class="comment">// Start the workers responsible to process the items in `jobs`.</span>
    <span class="keyword">for</span> w := <span class="integer">1</span>; w &lt;= <span class="integer">2</span>; w++ {
        <span class="keyword">go</span> a.worker(w, a.jobs, a.results)
    }

    <span class="keyword">return</span> a
}

<span class="comment">// Add is used to request the downloading of a new item.</span>
<span class="comment">// New items are simply send to the `jobs` channel.</span>
<span class="keyword">func</span> (a *pkgAcquire) Add(item Item) {
    <span class="comment">// The function is called from different goroutines.</span>
    <span class="comment">// We use a lock to prevent data inconsistencies.</span>
    a.jobsMutex.Lock()
    a.jobs &lt;- item
    a.pendingJobs++
    a.jobsMutex.Unlock()
}

<span class="comment">// A worker simply reads from the `jobs` channel and uses the different</span>
<span class="comment">// methods defined by `Item` to know what to do.</span>

<span class="keyword">func</span> (a *pkgAcquire) worker(id <span class="predefined-type">int</span>, jobs &lt;-<span class="keyword">chan</span> Item, results <span class="keyword">chan</span>&lt;- <span class="predefined-type">error</span>) {
    <span class="keyword">for</span> item := <span class="keyword">range</span> jobs {
        results &lt;- a.downloadItem(item)
    }
}

<span class="keyword">func</span> (a *pkgAcquire) downloadItem(item Item) <span class="predefined-type">error</span> {
    uri := item.DownloadURI()
    dest := item.DestFile(uri)

    <span class="comment">// Download the file</span>
    resp, err := http.Get(uri)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Err: %v</span><span class="char">\n</span><span class="char">\t</span><span class="content">%s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, item, err)
        <span class="keyword">return</span> err
    }
    <span class="keyword">defer</span> resp.Body.Close()

    <span class="comment">// Create the local file</span>
    os.MkdirAll(filepath.Dir(dest), <span class="octal">0755</span>)

    out, err := os.Create(dest)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }
    <span class="keyword">defer</span> out.Close()

    <span class="comment">// Copy the body to the local file</span>
    io.Copy(out, resp.Body)

    fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Get: %v</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, item)

    <span class="keyword">return</span> item.Done(a.cacheFile, a)
}

<span class="comment">// There is one remaining method to cover.</span>
<span class="comment">// The Acquire system will try to download items in parallel</span>
<span class="comment">// but the code often need to block until all items have been downloaded</span>
<span class="comment">// to continue. The next function is used to wait.</span>

<span class="comment">/**
 * Run downloads all items that have been added to this
 * download process.
 *
 * This method will block until the download completes.
 */</span>
<span class="keyword">func</span> (a *pkgAcquire) Run() <span class="predefined-type">error</span> {
    <span class="keyword">var</span> errors []<span class="predefined-type">string</span>
    <span class="keyword">var</span> err <span class="predefined-type">error</span>

    <span class="keyword">for</span> {
        <span class="comment">// Exit when there are no more remaining jobs</span>
        a.jobsMutex.Lock()
        <span class="keyword">if</span> a.pendingJobs == <span class="integer">0</span> {
            a.jobsMutex.Unlock()
            <span class="keyword">break</span>
        }
        a.jobsMutex.Unlock()

        <span class="comment">// Search for errors in the results</span>
        err = &lt;-a.results
        <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
            errors = <span class="predefined">append</span>(errors, err.Error())
        }

        a.jobsMutex.Lock()
        a.pendingJobs--
        a.jobsMutex.Unlock()
    }

    <span class="keyword">if</span> <span class="predefined">len</span>(errors) &gt; <span class="integer">0</span> {
        <span class="keyword">return</span> fmt.Errorf(strings.Join(errors, <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>))
    }

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="comment">// That's all for the Acquire system. What remains is the implementation</span>
<span class="comment">// of the various types of Item.</span>

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">/*
 * The first kind of `Item` we have to download are `InRelease` files.
 * These files contain metadata about other index files (ex: `Packages`)
 * present in the same repository and are used to check the integrity
 * of these files.
 */</span>

<span class="keyword">type</span> MetaIndexItem <span class="keyword">struct</span> { <span class="comment">// InRelease/Release files</span>
    <span class="comment">// The Debian source pointing to this repository.</span>
    <span class="comment">// The source contains fields required to determine the target URI.</span>
    source *pkgSource
}

<span class="keyword">func</span> NewMetaIndexItem(source *pkgSource) *MetaIndexItem {
    <span class="keyword">return</span> &amp;MetaIndexItem{
        source: source,
    }
}

<span class="keyword">func</span> (i *MetaIndexItem) DownloadURI() <span class="predefined-type">string</span> {
    <span class="comment">// Ex: http://deb.debian.org/debian/dists/buster/InRelease</span>
    <span class="keyword">return</span> i.source.URI + <span class="string"><span class="delimiter">&quot;</span><span class="content">/dists/</span><span class="delimiter">&quot;</span></span> + i.source.Dist + <span class="string"><span class="delimiter">&quot;</span><span class="content">/InRelease</span><span class="delimiter">&quot;</span></span>
}

<span class="keyword">func</span> (i *MetaIndexItem) DestFile(uri <span class="predefined-type">string</span>) <span class="predefined-type">string</span> {
    <span class="comment">// Ex: /var/lib/apt/lists/deb.debian.org_debian_dists_buster_InRelease</span>
    s := i.source
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/var/lib/apt/lists/</span><span class="delimiter">&quot;</span></span> +
        fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%s.%s_InRelease</span><span class="delimiter">&quot;</span></span>, s.EscapedURI(), s.Dist)
}

<span class="keyword">func</span> (i *MetaIndexItem) Done(c *CacheFile, acq *pkgAcquire) <span class="predefined-type">error</span> {
    s := i.source

    filePath := i.DestFile(s.URI)

    <span class="comment">// 1. Check the file integrity</span>

    <span class="comment">// Apt loads all GPG keys under /etc/apt/trusted.gpg.d/.</span>
    <span class="comment">// Here, for simplicity, we load only the single key we really need:</span>
    <span class="comment">// /etc/apt/trusted.gpg.d/debian-archive-buster-stable.gpg</span>
    publicKey := fmt.Sprintf(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">/etc/apt/trusted.gpg.d/debian-archive-%s-stable.gpg</span><span class="delimiter">&quot;</span></span>, s.Dist)
    decodedContent, err := gpgDecode(filePath, publicKey)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">the following signature couldn't be verified %s</span><span class="char">\n</span><span class="content">%v</span><span class="delimiter">&quot;</span></span>,
            filePath, err)
    }

    <span class="comment">// 2. Parse the content to extract metadata like the checksums</span>
    <span class="comment">// for other files to download</span>
    parser, err := deb822.NewParser(strings.NewReader(<span class="predefined-type">string</span>(decodedContent)))
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">malformed Release file: %v</span><span class="delimiter">&quot;</span></span>, err)
    }
    doc, err := parser.Parse()
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">malformed Release file: %v</span><span class="delimiter">&quot;</span></span>, err)
    }

    <span class="comment">// Extract values</span>
    s.doc = doc.Paragraphs[<span class="integer">0</span>]
    s.Codename = s.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Codename</span><span class="delimiter">&quot;</span></span>) <span class="comment">// Ex: buster</span>
    s.Suite = s.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Suite</span><span class="delimiter">&quot;</span></span>)       <span class="comment">// Ex: stable</span>
    s.Origin = s.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Origin</span><span class="delimiter">&quot;</span></span>)     <span class="comment">// Ex: Debian</span>
    s.Label = s.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Label</span><span class="delimiter">&quot;</span></span>)       <span class="comment">// Ex: Debian</span>
    s.Entries = <span class="predefined">make</span>(<span class="keyword">map</span>[<span class="predefined-type">string</span>]<span class="predefined-type">string</span>)
    <span class="keyword">for</span> _, entry := <span class="keyword">range</span> strings.Split(s.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">MD5Sum</span><span class="delimiter">&quot;</span></span>), <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>) {
        <span class="comment">// Ex: 0233ae8f041ca0f1aa5a7f395d326e80    57365 contrib/Contents-all.gz</span>
        fields := regexp.MustCompile(<span class="shell"><span class="delimiter">`</span><span class="content">\s+</span><span class="delimiter">`</span></span>).Split(entry, <span class="integer">-1</span>)
        relativePath := strings.TrimSpace(fields[<span class="integer">2</span>])
        md5sum := fields[<span class="integer">0</span>]
        s.Entries[relativePath] = md5sum
    }

    <span class="comment">// 3. Download the `Packages` files</span>
    acq.Add(NewIndexItem(s, <span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">amd64</span><span class="delimiter">&quot;</span></span>))
    <span class="comment">// The real code download other Packages files in addition</span>
    <span class="comment">// like the ones for the `contrib` and `non-free` components.</span>

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}
<span class="keyword">func</span> (i MetaIndexItem) String() <span class="predefined-type">string</span> {
    <span class="comment">// Ex: https://packages.grafana.com/oss/deb stable InRelease</span>
    <span class="keyword">return</span> fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%s stable InRelease</span><span class="delimiter">&quot;</span></span>, i.source.URI)
}

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">/*
 * The second kind of Item we have to download are index files
 * (Packages and Sources files).
 * In this implementation, we are ignoring Sources index files.
 * Packages index files list the Debian control files (DEBIAN/control)
 * with a few additional fields for every .deb package available.
 */</span>

<span class="keyword">type</span> IndexItem <span class="keyword">struct</span> { <span class="comment">// `Packages`/`Sources` files</span>
    source       *pkgSource
    component    <span class="predefined-type">string</span> <span class="comment">// Ex: main, free or non-free</span>
    architecture <span class="predefined-type">string</span> <span class="comment">// Ex: amd64</span>

}

<span class="keyword">func</span> NewIndexItem(source *pkgSource,
    component <span class="predefined-type">string</span>, architecture <span class="predefined-type">string</span>) *IndexItem {
    <span class="keyword">return</span> &amp;IndexItem{
        source:       source,
        component:    component,
        architecture: architecture,
    }
}

<span class="keyword">func</span> (i *IndexItem) DownloadURI() <span class="predefined-type">string</span> {
    <span class="comment">// Ex: http://deb.debian.org/debian/dists/buster/main/binary-all/Packages.xz</span>
    <span class="keyword">return</span> i.source.URI + <span class="string"><span class="delimiter">&quot;</span><span class="content">/dists/</span><span class="delimiter">&quot;</span></span> + i.source.Dist + <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span> + i.component +
        <span class="string"><span class="delimiter">&quot;</span><span class="content">/binary-</span><span class="delimiter">&quot;</span></span> + i.architecture + <span class="string"><span class="delimiter">&quot;</span><span class="content">/Packages.xz</span><span class="delimiter">&quot;</span></span>
}

<span class="keyword">func</span> (i *IndexItem) DestFile(uri <span class="predefined-type">string</span>) <span class="predefined-type">string</span> {
    <span class="comment">// Ex: /var/lib/apt/lists/</span>
    <span class="comment">//       deb.debian.org_debian_dists_buster_main_binary-amd64_Packages.xz</span>
    s := i.source
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">/var/lib/apt/lists/</span><span class="delimiter">&quot;</span></span> + fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%s.%s_%s_binary-%s_Packages.xz</span><span class="delimiter">&quot;</span></span>,
        s.EscapedURI(), s.Dist, i.component, i.architecture)
}

<span class="keyword">func</span> (i *IndexItem) Done(c *CacheFile, a *pkgAcquire) <span class="predefined-type">error</span> {
    s := i.source
    path := i.DestFile(s.URI)

    <span class="comment">// 1. Read the file</span>
    file, err := os.Open(path)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">missing file: %v</span><span class="delimiter">&quot;</span></span>, err)
    }
    <span class="keyword">defer</span> file.Close()

    b, err := ioutil.ReadAll(file)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">unable to open file %s: %v</span><span class="delimiter">&quot;</span></span>, path, err)
    }

    <span class="comment">// 2. Check integrity</span>
    hash := md5.New()
    <span class="keyword">if</span> _, err := io.Copy(hash, bytes.NewReader(b)); err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">unable to determine MD5 sum: %s</span><span class="delimiter">&quot;</span></span>, err)
    }
    md5sum := fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%x</span><span class="delimiter">&quot;</span></span>, hash.Sum(<span class="predefined-constant">nil</span>))
    md5sumRef := s.Entries[i.EntryName()]
    <span class="keyword">if</span> md5sum != md5sumRef {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">found MD5 mismatch: %v != %v</span><span class="delimiter">&quot;</span></span>, md5sum, md5sumRef)
    }

    <span class="comment">// 3. Extract content</span>
    r, err := xz.NewReader(bytes.NewReader(b))
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">unable to open xz file: %v</span><span class="delimiter">&quot;</span></span>, err)
    }
    content, err := io.ReadAll(r)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">unable to read index file content: %v</span><span class="delimiter">&quot;</span></span>, err)
    }

    <span class="comment">// 4. Parse content</span>
    parser, err := deb822.NewParser(strings.NewReader(<span class="predefined-type">string</span>(content)))
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">malformed index file: %v</span><span class="delimiter">&quot;</span></span>, err)
    }
    doc, err := parser.Parse()
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">malformed index file: %v</span><span class="delimiter">&quot;</span></span>, err)
    }

    <span class="comment">// 5. Add the package into the Apt cache.</span>
    <span class="keyword">for</span> _, paragraph := <span class="keyword">range</span> doc.Paragraphs {
        c.AddPackage(&amp;Package{
            doc:    paragraph,
            source: s,
        })
    }

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="comment">// EntryName returns the key in MD5Sum for this file in the Release file.</span>
<span class="keyword">func</span> (i IndexItem) EntryName() <span class="predefined-type">string</span> {
    <span class="comment">// Ex: main/binary-am64/Packages</span>
    <span class="keyword">return</span> fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%s/binary-%s/Packages.xz</span><span class="delimiter">&quot;</span></span>, i.component, i.architecture)
}

<span class="keyword">func</span> (i IndexItem) String() <span class="predefined-type">string</span> {
    <span class="comment">// Ex: https://packages.grafana.com/oss/deb stable/main amd64 Packages</span>
    <span class="keyword">return</span> fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%s stable/%s %s Packages</span><span class="delimiter">&quot;</span></span>,
        i.source.URI, i.component, i.architecture)
}

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">/*
 * The last kind of Item we have to download are .deb archives that will
 * be passed to the dpkg command to proceed to the installation.
 * These files are downloaded under /var/cache/apt/archives/.
 */</span>

<span class="keyword">type</span> PackageItem <span class="keyword">struct</span> { <span class="comment">// `.deb` files</span>
    <span class="comment">// The package metadata associated with the archive to download.</span>
    pkg *Package
}

<span class="keyword">func</span> NewPackageItem(pkg *Package) *PackageItem {
    <span class="keyword">return</span> &amp;PackageItem{
        pkg: pkg,
    }
}

<span class="keyword">func</span> (i *PackageItem) DownloadURI() <span class="predefined-type">string</span> {
    <span class="comment">// Ex: http://deb.debian.org/debian/pool/main/r/rsync/rsync_3.2.3_amd64.deb</span>
    <span class="keyword">return</span> i.pkg.source.URI + <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span> + i.pkg.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Filename</span><span class="delimiter">&quot;</span></span>)
}

<span class="keyword">func</span> (i *PackageItem) DestFile(uri <span class="predefined-type">string</span>) <span class="predefined-type">string</span> {
    <span class="comment">// Ex: /var/cache/apt/archives/rsync_3.2.3-4_amd64.deb</span>
    pkg := i.pkg
    pkg.cacheFilepath = <span class="string"><span class="delimiter">&quot;</span><span class="content">/var/cache/apt/archives/</span><span class="delimiter">&quot;</span></span> + filepath.Base(uri)
    <span class="keyword">return</span> pkg.cacheFilepath
}

<span class="keyword">func</span> (i *PackageItem) Done(c *CacheFile, a *pkgAcquire) <span class="predefined-type">error</span> {
    <span class="comment">// 1. Check file integrity</span>
    f, err := os.Open(i.pkg.cacheFilepath)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }
    <span class="keyword">defer</span> f.Close()

    h := sha256.New()
    <span class="keyword">if</span> _, err := io.Copy(h, f); err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }

    indexChecksum := i.pkg.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">SHA256</span><span class="delimiter">&quot;</span></span>)
    effectiveChecksum := fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%x</span><span class="delimiter">&quot;</span></span>, h.Sum(<span class="predefined-constant">nil</span>))

    <span class="keyword">if</span> indexChecksum != effectiveChecksum {
        <span class="keyword">return</span> fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">invalid checksum for %s</span><span class="delimiter">&quot;</span></span>, i.pkg.cacheFilepath)
    }

    <span class="comment">// 2. Nothing more to do.</span>
    <span class="comment">// The archive will be processed later when delegating to the `dpkg` command.</span>

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="keyword">func</span> (i PackageItem) String() <span class="predefined-type">string</span> {
    <span class="comment">// Ex: https://grafana.com/oss/deb stable/main amd64 grafana amd64 7.5.5</span>
    pkg := i.pkg
    <span class="keyword">return</span> fmt.Sprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%s stable/main %s %s %s</span><span class="delimiter">&quot;</span></span>, pkg.source.URI,
        pkg.Name(), pkg.Architecture(), pkg.Version())
}

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">//</span>
<span class="comment">// The Apt Cache</span>
<span class="comment">//</span>

<span class="comment">// We try to using the same naming as for the real implementation</span>
<span class="comment">// using similar structs but containing only the main fields.</span>

<span class="comment">// CacheFile is the high-level component for the Apt cache.</span>
<span class="keyword">type</span> CacheFile <span class="keyword">struct</span> {
    cache    *pkgCache
    depCache *pkgDepCache
    sources  []*pkgSource
}

<span class="comment">// pkgCache contains all known packages</span>
<span class="comment">// (found in Dpkg database and in repositories)</span>
<span class="keyword">type</span> pkgCache <span class="keyword">struct</span> {
    packages <span class="keyword">map</span>[<span class="predefined-type">string</span>]*Package <span class="comment">// The key is the package name</span>
}

<span class="comment">// pkgDepCache contains the state information for every package</span>
<span class="comment">// (installed, to install, upgradable, ...).</span>
<span class="keyword">type</span> pkgDepCache <span class="keyword">struct</span> {
    states <span class="keyword">map</span>[<span class="predefined-type">string</span>]*StateCache
    <span class="comment">// The ordered list of packages waiting to be installed.</span>
    order []<span class="predefined-type">string</span>
}

<span class="comment">// pkgSource represents a single line in a source.list file.</span>
<span class="keyword">type</span> pkgSource <span class="keyword">struct</span> {
    doc deb822.Paragraph <span class="comment">// `Release` file content</span>

    <span class="comment">// parsed from the sources.list file</span>
    Type <span class="predefined-type">string</span>
    URI  <span class="predefined-type">string</span>
    Dist <span class="predefined-type">string</span>

    <span class="comment">// parsed from the Packages file</span>
    Codename <span class="predefined-type">string</span>
    Suite    <span class="predefined-type">string</span>
    Origin   <span class="predefined-type">string</span>
    Label    <span class="predefined-type">string</span>
    Entries  <span class="keyword">map</span>[<span class="predefined-type">string</span>]<span class="predefined-type">string</span> <span class="comment">// Checksums of all repository files</span>
}

<span class="comment">// EscapedURI returns a name based on the URI that can be used in filename.</span>
<span class="comment">// Indeed, most retrieved files are stored under /var/lib/apt/</span>
<span class="comment">// and are named after their source.</span>
<span class="keyword">func</span> (s *pkgSource) EscapedURI() <span class="predefined-type">string</span> {
    <span class="keyword">return</span> strings.ReplaceAll(strings.TrimPrefix(s.URI, <span class="string"><span class="delimiter">&quot;</span><span class="content">http://</span><span class="delimiter">&quot;</span></span>), <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">_</span><span class="delimiter">&quot;</span></span>)
}

<span class="comment">// The core of the Apt cache is the list of packages.</span>

<span class="comment">// Package is a Debian package.</span>
<span class="keyword">type</span> Package <span class="keyword">struct</span> {
    <span class="comment">// The metadata as present in `Packages` or `status` file</span>
    doc deb822.Paragraph
    <span class="comment">// The source where this package is coming from.</span>
    <span class="comment">// Can be undefined for already installed packages.</span>
    source *pkgSource

    <span class="comment">// The path under /var/cache/apt/packages.</span>
    <span class="comment">// Initialized after the download of the package.</span>
    cacheFilepath <span class="predefined-type">string</span>
}

<span class="comment">// We expose a few additional methods to extract attributes</span>
<span class="comment">// from the underlying DEB822 document.</span>

<span class="keyword">func</span> (p *Package) Name() <span class="predefined-type">string</span> {
    <span class="keyword">return</span> p.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Package</span><span class="delimiter">&quot;</span></span>)
}

<span class="keyword">func</span> (p *Package) Version() <span class="predefined-type">string</span> {
    <span class="keyword">return</span> p.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Version</span><span class="delimiter">&quot;</span></span>)
}

<span class="keyword">func</span> (p *Package) Architecture() <span class="predefined-type">string</span> {
    <span class="keyword">return</span> p.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Architecture</span><span class="delimiter">&quot;</span></span>)
}

<span class="keyword">func</span> (p *Package) Depends() []Dependency {
    <span class="keyword">return</span> ParseDependencies(p.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Depends</span><span class="delimiter">&quot;</span></span>))
}

<span class="keyword">func</span> (p *Package) Suggests() []Dependency {
    <span class="keyword">return</span> ParseDependencies(p.doc.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Suggests</span><span class="delimiter">&quot;</span></span>))
}

<span class="keyword">type</span> Dependency <span class="keyword">struct</span> {
    Name     <span class="predefined-type">string</span>
    Version  <span class="predefined-type">string</span>
    Relation <span class="predefined-type">string</span>
}

<span class="keyword">func</span> ParseDependencies(values <span class="predefined-type">string</span>) []Dependency {
    <span class="comment">// Ex: &quot;adduser, gpgv | gpgv2 | gpgv1, libapt-pkg5.0 (&gt;= 1.7.0~alpha3~)&quot;</span>
    depsValues := strings.TrimSpace(values)
    <span class="keyword">if</span> depsValues == <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>
    }

    <span class="keyword">var</span> deps []Dependency
    <span class="keyword">for</span> _, value := <span class="keyword">range</span> strings.Split(depsValues, <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>) {
        deps = <span class="predefined">append</span>(deps, ParseDependency(value))
    }
    <span class="keyword">return</span> deps
}

<span class="keyword">func</span> ParseDependency(value <span class="predefined-type">string</span>) Dependency {
    <span class="comment">// Example of syntax:</span>
    <span class="comment">// &quot;adduser&quot;, &quot;gpgv | gpgv2&quot;, &quot;libc6 (&gt;= 2.15)&quot;,</span>
    <span class="comment">// &quot;python3:any (&gt;= 3.5~)&quot;, &quot;foo [i386]&quot;, &quot;perl:any&quot;, &quot;perlapi-5.28.0&quot;</span>

    <span class="keyword">var</span> dep Dependency

    r := regexp.MustCompile(<span class="shell"><span class="delimiter">`</span><span class="content">^(?P&lt;name&gt;[\w\.-]+)(?:[:]\w+)?</span><span class="delimiter">`</span></span> +
        <span class="shell"><span class="delimiter">`</span><span class="content">(?: [(](?P&lt;relation&gt;(?:&gt;&gt;|&gt;=|=|&lt;=|&lt;&lt;)) </span><span class="delimiter">`</span></span> +
        <span class="shell"><span class="delimiter">`</span><span class="content">(?P&lt;version&gt;\S+)[)])?(?: [|].*)?$</span><span class="delimiter">`</span></span>)
    res := r.FindStringSubmatch(value)
    names := r.SubexpNames()
    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> res {
        <span class="keyword">switch</span> names[i] {
        <span class="keyword">case</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>:
            dep.Name = res[i]
        <span class="keyword">case</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">relation</span><span class="delimiter">&quot;</span></span>:
            dep.Relation = res[i]
        <span class="keyword">case</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">version</span><span class="delimiter">&quot;</span></span>:
            dep.Version = res[i]
        }
    }
    <span class="keyword">return</span> dep
}

<span class="comment">// That's all for the different structures relating to the Apt cache.</span>

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">// Now, we need to initialize the three main components.</span>
<span class="comment">// The first step is thus to create the array containing all known packages.</span>
<span class="comment">// This array will be populated in the successive steps.</span>

<span class="keyword">func</span> (c *CacheFile) BuildCaches() {
    c.cache = &amp;pkgCache{
        packages: <span class="predefined">make</span>(<span class="keyword">map</span>[<span class="predefined-type">string</span>]*Package),
    }
}

<span class="comment">// The second step is to read the lists of sources to find the `Packages` files</span>
<span class="comment">// containing the list of available packages.</span>
<span class="comment">// So, we need a function to parse these local source files.</span>

<span class="comment">// ParseSourceFile parses a single source file.</span>
<span class="comment">// It only supports the common multi-line format,</span>
<span class="comment">// and not the most recent DEB822 format.</span>
<span class="keyword">func</span> ParseSourceFile(content <span class="predefined-type">string</span>) []*pkgSource {
    <span class="keyword">var</span> results []*pkgSource

    scanner := bufio.NewScanner(strings.NewReader(content))
    <span class="comment">// Read line by line</span>
    <span class="keyword">for</span> scanner.Scan() {
        line := scanner.Text()
        <span class="keyword">if</span> strings.TrimSpace(line) == <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> {
            <span class="comment">// Ignore blank lines</span>
            <span class="keyword">continue</span>
        }
        <span class="keyword">if</span> strings.HasPrefix(<span class="string"><span class="delimiter">&quot;</span><span class="content">#</span><span class="delimiter">&quot;</span></span>, line) {
            <span class="comment">// Ignore comments</span>
            <span class="keyword">continue</span>
        }
        parts := strings.Split(line, <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>)
        <span class="comment">// Basic parser (ignore some options or unused attributes)</span>
        source := &amp;pkgSource{
            Type: parts[<span class="integer">0</span>],
            URI:  parts[<span class="integer">1</span>],
            Dist: parts[<span class="integer">2</span>],
        }
        results = <span class="predefined">append</span>(results, source)
    }

    <span class="keyword">return</span> results
}

<span class="comment">// BuildSourceList parses every source file.</span>
<span class="keyword">func</span> (c *CacheFile) BuildSourceList() {
    <span class="keyword">var</span> sources []*pkgSource

    <span class="comment">// Read /etc/apt/sources.list</span>
    mainPath := <span class="string"><span class="delimiter">&quot;</span><span class="content">/etc/apt/sources.list</span><span class="delimiter">&quot;</span></span>
    <span class="keyword">if</span> _, err := os.Stat(mainPath); !os.IsNotExist(err) {
        content, err := ioutil.ReadFile(mainPath)
        <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
            fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">E: Unable to read source file</span><span class="char">\n</span><span class="char">\t</span><span class="content">%s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, err)
            os.Exit(<span class="integer">1</span>)
        }
        sources = <span class="predefined">append</span>(sources, ParseSourceFile(<span class="predefined-type">string</span>(content))...)
    }

    <span class="comment">// Read /etc/apt/sources.list.d/</span>
    dirPath := <span class="string"><span class="delimiter">&quot;</span><span class="content">/etc/apt/sources.list.d/</span><span class="delimiter">&quot;</span></span>
    <span class="keyword">if</span> _, err := os.Stat(dirPath); !os.IsNotExist(err) {
        files, err := ioutil.ReadDir(dirPath)
        <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
            fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">E: Unable to read source dir</span><span class="char">\n</span><span class="char">\t</span><span class="content">%s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, err)
            os.Exit(<span class="integer">1</span>)
        }
        <span class="keyword">for</span> _, file := <span class="keyword">range</span> files {
            filePath := filepath.Join(dirPath, file.Name())
            content, err := ioutil.ReadFile(filePath)
            <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
                fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">E: Unable to read source file</span><span class="char">\n</span><span class="char">\t</span><span class="content">%s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, err)
                os.Exit(<span class="integer">1</span>)
            }
            sources = <span class="predefined">append</span>(sources, ParseSourceFile(<span class="predefined-type">string</span>(content))...)
        }
    }
    c.sources = sources
}

<span class="comment">// The last step is to read the Dpkg database</span>
<span class="comment">// to determine the packages already installed.</span>
<span class="comment">// Therefore, we need a function to parse the status file.</span>

<span class="keyword">func</span> ParseStatus() (*deb822.Document, <span class="predefined-type">error</span>) {
    f, err := os.Open(<span class="string"><span class="delimiter">&quot;</span><span class="content">/var/lib/dpkg/status</span><span class="delimiter">&quot;</span></span>)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>, err
    }
    parser, err := deb822.NewParser(f)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>, err
    }
    statusContent, err := parser.Parse()
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>, err
    }
    <span class="keyword">return</span> &amp;statusContent, <span class="predefined-constant">nil</span>
}

<span class="keyword">func</span> (c *CacheFile) BuildDepCache() {
    states := <span class="predefined">make</span>(<span class="keyword">map</span>[<span class="predefined-type">string</span>]*StateCache)

    <span class="comment">// Read /var/lib/dpkg/status</span>
    status, err := ParseStatus()
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">E: The package lists or status file could not be parsed.</span><span class="delimiter">&quot;</span></span>)
        os.Exit(<span class="integer">1</span>)
    }

    <span class="comment">// Add state for packages already installed</span>
    <span class="keyword">for</span> _, pkg := <span class="keyword">range</span> status.Paragraphs {
        <span class="comment">// The status file also contains packages</span>
        <span class="comment">// that were partially installed or removed.</span>
        <span class="keyword">if</span> !strings.Contains(pkg.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Status</span><span class="delimiter">&quot;</span></span>), <span class="string"><span class="delimiter">&quot;</span><span class="content">installed</span><span class="delimiter">&quot;</span></span>) {
            <span class="keyword">continue</span>
        }
        state, ok := states[pkg.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Package</span><span class="delimiter">&quot;</span></span>)]
        <span class="keyword">if</span> !ok {
            state = &amp;StateCache{}
            states[pkg.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Package</span><span class="delimiter">&quot;</span></span>)] = state
        }
        state.CurrentVersion = pkg.Value(<span class="string"><span class="delimiter">&quot;</span><span class="content">Version</span><span class="delimiter">&quot;</span></span>)
    }

    c.depCache = &amp;pkgDepCache{
        states: states,
    }
}

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">// We now have the three functions required to initialize the Apt cache.</span>
<span class="comment">// We will hide them behind a simple method.</span>

<span class="keyword">func</span> (c *CacheFile) Open() {
    <span class="comment">// Initialize the Acquire system to download file from repositories</span>
    acq := NewPkgAcquire(c)

    <span class="comment">// Initialize the cache structure</span>
    <span class="keyword">if</span> c.sources == <span class="predefined-constant">nil</span> {
        c.BuildCaches()
        c.BuildSourceList()
        c.BuildDepCache()
    }

    <span class="comment">// Download items from repositories</span>
    <span class="keyword">for</span> _, source := <span class="keyword">range</span> c.sources {
        <span class="keyword">if</span> source.Type == <span class="string"><span class="delimiter">&quot;</span><span class="content">deb-src</span><span class="delimiter">&quot;</span></span> {
            <span class="keyword">continue</span> <span class="comment">// We are interested only in binary packages</span>
        }
        acq.Add(NewMetaIndexItem(source))
    }

    <span class="comment">// Wait for all items to be downloaded to return</span>
    err := acq.Run()
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">E: Unable to fetch resources</span><span class="char">\n</span><span class="char">\t</span><span class="content">%s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, err)
        os.Exit(<span class="integer">1</span>)
    }
}

<span class="comment">// As we have implemented before, the cache content is populated</span>
<span class="comment">// from the `Done()` methods of the different types of `Item`.</span>
<span class="comment">// We need to expose additional methods to easily add or retrieve</span>
<span class="comment">// these packages and their state.</span>

<span class="keyword">func</span> (c *CacheFile) AddPackage(p *Package) {
    c.cache.packages[p.Name()] = p
}

<span class="keyword">func</span> (c *CacheFile) GetPackage(name <span class="predefined-type">string</span>) *Package {
    <span class="keyword">if</span> p, ok := c.cache.packages[name]; ok {
        <span class="keyword">return</span> p
    }
    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="keyword">func</span> (c *CacheFile) GetPackages() []*Package {
    values := <span class="predefined">make</span>([]*Package, <span class="integer">0</span>, <span class="predefined">len</span>(c.cache.packages))
    <span class="keyword">for</span> _, v := <span class="keyword">range</span> c.cache.packages {
        values = <span class="predefined">append</span>(values, v)
    }
    <span class="keyword">return</span> values
}

<span class="keyword">func</span> (c *CacheFile) GetState(pkg *Package) *StateCache {
    <span class="keyword">var</span> state *StateCache
    state, ok := c.depCache.states[pkg.Name()]
    <span class="keyword">if</span> !ok {
        <span class="comment">// Only the state of installed packages is present.</span>
        <span class="comment">// We defer the initialization for other packages until</span>
        <span class="comment">// the first access.</span>
        state = &amp;StateCache{
            CandidateVersion: pkg.Version(),
            flagInstall:      <span class="predefined-constant">false</span>,
        }
        c.depCache.states[pkg.Name()] = state
    }
    <span class="keyword">return</span> state
}

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">// We are almost done with the Apt cache.</span>
<span class="comment">// We have discussed several times about the state we keep about each package</span>
<span class="comment">// without explaining what it means.</span>

<span class="keyword">type</span> StateCache <span class="keyword">struct</span> {
    <span class="comment">// The version that can be installed determined using sources.</span>
    CandidateVersion <span class="predefined-type">string</span>
    <span class="comment">// The version currently installed determined using the Dpkg database.</span>
    CurrentVersion <span class="predefined-type">string</span>
    <span class="comment">// A flag to determine if the package is marked for installation.</span>
    flagInstall <span class="predefined-type">bool</span>
}

<span class="keyword">func</span> (s *StateCache) Upgradable() <span class="predefined-type">bool</span> {
    <span class="keyword">return</span> s.CurrentVersion != <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> &amp;&amp;
        s.CandidateVersion != <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> &amp;&amp; s.CurrentVersion != s.CandidateVersion
}

<span class="keyword">func</span> (s *StateCache) Install() <span class="predefined-type">bool</span> {
    <span class="keyword">return</span> s.flagInstall
}

<span class="keyword">func</span> (s *StateCache) Installed() <span class="predefined-type">bool</span> {
    <span class="keyword">return</span> s.CurrentVersion != <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>
}

<span class="comment">// When installing a package, we must make sure its dependencies</span>
<span class="comment">// are already installed or we need to install them first.</span>
<span class="comment">// The logic is rather complicated as many things can go wrong</span>
<span class="comment">// with dependency management like conflicts between two packages.</span>
<span class="comment">// For this article, we will use a very basic approach.</span>
<span class="comment">// We ignore versions completely and install each missing dependencies</span>
<span class="comment">// without checking if it brokes other packages. This is another</span>
<span class="comment">// reason why you must not run this code on your host directly :).</span>

<span class="keyword">func</span> (c *CacheFile) MarkForInstallation(pkgName <span class="predefined-type">string</span>) {
    pkg := c.GetPackage(pkgName)
    <span class="keyword">if</span> pkg == <span class="predefined-constant">nil</span> {
        fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">E: Unable to locate package %s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, pkgName)
        os.Exit(<span class="integer">1</span>)
    }

    state := c.GetState(pkg)
    <span class="keyword">if</span> state.Installed() || state.Install() {
        <span class="comment">// Already installed or marked for installation</span>
        <span class="keyword">return</span>
    }

    <span class="comment">// Make sure to mark the package before checking its dependencies</span>
    <span class="comment">// to prevent infinite cycles</span>
    state.CandidateVersion = pkg.Version()
    state.flagInstall = <span class="predefined-constant">true</span>

    <span class="comment">// Mark dependencies recursively</span>
    <span class="keyword">for</span> _, dep := <span class="keyword">range</span> pkg.Depends() {
        c.MarkForInstallation(dep.Name)
    }

    <span class="comment">// Add dependencies first in the installation sequence order</span>
    c.depCache.order = <span class="predefined">append</span>(c.depCache.order, pkgName)
}

<span class="comment">// We end this section with an utility method to report the total</span>
<span class="comment">// number of packages that will be installed.</span>
<span class="comment">// This number differs commonly as packages have dependencies</span>
<span class="comment">// that must be installed and we will use this method to notify</span>
<span class="comment">// the user that more packages will be installed as the ones</span>
<span class="comment">// passed in argument.</span>

<span class="keyword">func</span> (c *CacheFile) InstCount() <span class="predefined-type">int</span> {
    count := <span class="integer">0</span>
    <span class="keyword">for</span> _, state := <span class="keyword">range</span> c.depCache.states {
        <span class="keyword">if</span> state.Install() {
            count++
        }
    }
    <span class="keyword">return</span> count
}

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">//</span>
<span class="comment">// Main</span>
<span class="comment">//</span>

<span class="comment">// We have everything we need to implement the command `apt install`.</span>
<span class="comment">// We will integrate everything we have covered so far.</span>

<span class="keyword">func</span> main() {
    <span class="keyword">var</span> pkgNames []<span class="predefined-type">string</span>
    <span class="comment">// The command `apt install` can be called without any package to install.</span>
    <span class="keyword">if</span> <span class="predefined">len</span>(os.Args) &gt; <span class="integer">1</span> {
        pkgNames = <span class="predefined">append</span>(pkgNames, os.Args[<span class="integer">1</span>:]...)
    }

    <span class="comment">// Load the Cache</span>
    cache := &amp;CacheFile{}
    cache.Open()

    <span class="comment">// Search for the packages to install</span>
    pkgs := <span class="predefined">make</span>(<span class="keyword">map</span>[<span class="predefined-type">string</span>]*Package)
    <span class="keyword">for</span> _, pkgName := <span class="keyword">range</span> pkgNames {
        <span class="comment">// The command `apt install` also supports `.deb` file.</span>
        <span class="comment">// We ignore this for simplicity to avoid</span>
        <span class="comment">// duplicating code from the previous parts of this blog post.</span>
        <span class="comment">// Check https://github.com/julien-sobczak/linux-packages-under-the-hood</span>
        <span class="comment">// for a more complete implementation.</span>

        cache.MarkForInstallation(pkgName)
        pkgs[pkgName] = cache.GetPackage(pkgName)
    }

    <span class="comment">// Print out the list of additional packages to install</span>
    <span class="keyword">if</span> cache.InstCount() != <span class="predefined">len</span>(pkgNames) {
        <span class="keyword">var</span> extras []<span class="predefined-type">string</span>
        <span class="keyword">for</span> _, pkg := <span class="keyword">range</span> cache.GetPackages() {
            state := cache.GetState(pkg)
            <span class="keyword">if</span> !state.Install() {
                <span class="keyword">continue</span>
            }
            <span class="keyword">if</span> _, ok := pkgs[pkg.Name()]; !ok {
                extras = <span class="predefined">append</span>(extras, pkg.Name())
            }
        }
        fmt.Printf(
            <span class="string"><span class="delimiter">&quot;</span><span class="content">The following additional packages will be installed:</span><span class="char">\n</span><span class="char">\t</span><span class="content">%s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>,
            strings.Join(extras, <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>))
    }

    <span class="comment">// Print out the list of suggested packages</span>
    <span class="keyword">var</span> suggests []<span class="predefined-type">string</span>
    <span class="keyword">for</span> _, pkg := <span class="keyword">range</span> cache.GetPackages() {
        state := cache.GetState(pkg)

        <span class="comment">// Just look at the ones we want to install</span>
        <span class="keyword">if</span> !state.Install() {
            <span class="keyword">continue</span>
        }

        <span class="comment">// Get the suggestions for the candidate version</span>
        <span class="keyword">for</span> _, dependency := <span class="keyword">range</span> pkg.Suggests() {
            suggests = <span class="predefined">append</span>(suggests, dependency.Name)
        }
    }
    <span class="keyword">if</span> <span class="predefined">len</span>(suggests) &gt; <span class="integer">0</span> {
        fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Suggested packages:</span><span class="char">\n</span><span class="char">\t</span><span class="content">%s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, strings.Join(suggests, <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>))
    }

    err := InstallPackages(cache)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        fmt.Printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">E: %s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, err)
        os.Exit(<span class="integer">1</span>)
    }
}

<span class="keyword">func</span> InstallPackages(cache *CacheFile) <span class="predefined-type">error</span> {
    acq := NewPkgAcquire(cache)

    <span class="comment">// 1. Download package archives</span>
    <span class="keyword">for</span> _, pkgName := <span class="keyword">range</span> cache.depCache.order {
        pkg := cache.GetPackage(pkgName)
        acq.Add(NewPackageItem(pkg))
    }
    err := acq.Run()
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }

    <span class="comment">// 2. Run the command `dpkg -i` to install them</span>
    <span class="keyword">var</span> archives []<span class="predefined-type">string</span>
    <span class="keyword">for</span> _, pkgName := <span class="keyword">range</span> cache.depCache.order {
        pkg := cache.GetPackage(pkgName)
        archives = <span class="predefined">append</span>(archives, pkg.cacheFilepath)
    }

    <span class="comment">// We delegate to the dpkg command to avoid repeating the previous code</span>
    <span class="comment">// but the complete code source of this repository reuse the same code.</span>
    <span class="comment">// Check https://github.com/julien-sobczak/linux-packages-under-the-hood</span>
    out, err := exec.Command(<span class="string"><span class="delimiter">&quot;</span><span class="content">dpkg</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">-i</span><span class="delimiter">&quot;</span></span>, strings.Join(archives, <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>)).Output()
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> err
    }
    fmt.Print(<span class="predefined-type">string</span>(out))

    <span class="keyword">return</span> <span class="predefined-constant">nil</span>
}

<span class="comment">///////////////////////////////////////////////////////////</span>

<span class="comment">// Helpers</span>

<span class="comment">// gpgDecode checks the GPP signature of a clearsigned document and</span>
<span class="comment">// returns the content.</span>
<span class="keyword">func</span> gpgDecode(filename <span class="predefined-type">string</span>, publicKey <span class="predefined-type">string</span>) ([]<span class="predefined-type">byte</span>, <span class="predefined-type">error</span>) {
    <span class="comment">// Open gpg clearsigned document</span>
    r, err := os.Open(filename)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>, fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">error opening public key: %s</span><span class="delimiter">&quot;</span></span>, err)
    }
    <span class="keyword">defer</span> r.Close()

    <span class="comment">// Read the content</span>
    data, err := ioutil.ReadAll(r)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>, err
    }

    <span class="comment">// Decode the content</span>
    b, _ := clearsign.Decode(data)
    <span class="keyword">if</span> b == <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>, fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">not PGP signed</span><span class="delimiter">&quot;</span></span>)
    }

    <span class="comment">// Open the public key to validate the signature</span>
    rk, err := os.Open(publicKey)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>, fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">error opening public key: %s</span><span class="delimiter">&quot;</span></span>, err)
    }
    <span class="keyword">defer</span> r.Close()
    keyring, err := openpgp.ReadKeyRing(rk) <span class="comment">// binary</span>
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>, fmt.Errorf(<span class="string"><span class="delimiter">&quot;</span><span class="content">failed to parse public key: %v</span><span class="delimiter">&quot;</span></span>, err)
    }

    <span class="comment">// Check the signature using the public key</span>
    _, err = openpgp.CheckDetachedSignature(keyring,
        bytes.NewBuffer(b.Bytes), b.ArmoredSignature.Body)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        <span class="keyword">return</span> <span class="predefined-constant">nil</span>, err
    }

    <span class="keyword">return</span> b.Plaintext, <span class="predefined-constant">nil</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>üéâ <strong>We have finished with the command <code>apt</code>.</strong> We have also finished with this article! We created a Debian archive using a basic Go program and we install the package using Go versions of <code>dpkg</code> and <code>apt</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="one_last_word">"One" Last Word</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Linux packages are just archives containing files to extract into a different system. The problem is trivial but the evil always comes from details.</p>
</div>
<div class="paragraph">
<p>In this article, we have glimpsed at some of the challenges that a package manager must address. Packages use others packages which means the package manager must face one of the most difficult problems in computing, <a href="https://en.wikipedia.org/wiki/Dependency_hell">dependency management</a>. Despite that, Dpkg and Apt are still approachable programs.</p>
</div>
<div class="paragraph">
<p>We wrote basic versions from scratch using only a few hundreds of lines of Go code. The biggest obstacle was that the commands <code>dpkg</code> and <code>apt</code> are interactive and try do too much to avoid to rely on the user to fix problems, which explains why the sum of the two programs represents approximatively 100,000 lines of C and C++ code.</p>
</div>
<div class="paragraph">
<p>If you are managing a large pool of servers like a datacenter, reimplementing your own package manager can be interesting. For example, you could centralize all local databases to ensure that all machines share the same state, or you can take corrective actions like excluding a server from the pool when an upgrade ends in a bad state. Google provides a great example of application. They decided to implement their own package management system. ‚ÄúAny package change is guaranteed to succeed, or the machine is rolled back completely to the previous state. If the rollback fails, the machine is sent through our repairs process for reinstallation and potential hardware replacement. This approach allows us to eliminate much of the complexity of the package states.‚Äù<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>. The decision was surely not obvious, but the benefits are for sure obvious.</p>
</div>
<div class="paragraph">
<p>Implementing a package manager from scratch can be intimidating, but as we have seen in this article, the reality is not so bad, especially if we consider the long list of features that Apt supports that are not useful when managing a large number of homogenous machines in an automated way.</p>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Building Secure and Reliable Systems, O&#8217;Reilly, Chapter 9 - Design for Recovery, Footnote 18
</div>
</div>
      </div>

      <div class="author-bio">
  <img src="/img/me.jpg" />
  <p><strong>About the author</strong></p>
  <p>Julien Sobczak works as a software developer for Scaleway, a French cloud provider. He is a passionate reader who likes to see the world differently to measure the extent of his ignorance. His main areas of interest are productivity (doing less and better), human potential, and everything that contributes in being a better person (including a better dad and a better developer).</p>
  <a href="https://fr.linkedin.com/in/julien-sobczak-56780a91">Read Full Profile</a>
</div>

    </article>

  </div>
</section>





  
<section id="labels" class="labels">
  <div class="container">

  <div>
    <h2>Tags</h2>
    <hr class="star-light">
  </div>


  <ul class="labels">
    <!-- TODO refactor remove useless tags and rename them. Ex: agile => people -->
    <!-- <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/agile.html"><span class="label-icon label-team-icon label-white-icon"></span><span class="label-text">People<span class="label-count">0</span></span></a>
      </div>
    </li> -->
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/architecture.html"><span class="label-icon label-architecture-icon label-white-icon"></span><span class="label-text">Architecture<span class="label-count">13</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/classics.html"><span class="label-icon label-classics-icon label-white-icon"></span><span class="label-text">Classics<span class="label-count">3</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/craftsmanship.html"><span class="label-icon label-craftsmanship-icon label-white-icon"></span><span class="label-text">Craftsmanship<span class="label-count">11</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/computer-science.html"><span class="label-icon label-computer-science-icon label-white-icon"></span><span class="label-text">Computer Science<span class="label-count">9</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/data.html"><span class="label-icon label-data-icon label-white-icon"></span><span class="label-text">Data<span class="label-count">6</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/devops.html"><span class="label-icon label-devops-icon label-white-icon"></span><span class="label-text">Devops<span class="label-count">11</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/frameworks.html"><span class="label-icon label-frameworks-icon label-white-icon"></span><span class="label-text">Frameworks<span class="label-count">10</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/human.html"><span class="label-icon label-human-icon label-white-icon"></span><span class="label-text">Human<span class="label-count">11</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/languages.html"><span class="label-icon label-languages-icon label-white-icon"></span><span class="label-text">Languages<span class="label-count">6</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/learning.html"><span class="label-icon label-reversing-icon label-white-icon"></span><span class="label-text">Learning<span class="label-count">31</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/management.html"><span class="label-icon label-management-icon label-white-icon"></span><span class="label-text">Management<span class="label-count">28</span></span></a>
      </div>
    </li>
    <!-- Not pertinent
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/popular.html"><span class="label-icon label-popular-icon label-white-icon"></span><span class="label-text">Popular<span class="label-count">0</span></span></a>
      </div>
    </li>
    -->
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/productivity.html"><span class="label-icon label-productivity-icon label-white-icon"></span><span class="label-text">Productivity<span class="label-count">16</span></span></a>
      </div>
    </li>
    <li>
      <div class="label">
        <span class="sunshine"></span><a href="/tags/tools.html"><span class="label-icon label-tools-icon label-white-icon"></span><span class="label-text">Tools<span class="label-count">9</span></span></a>
      </div>
    </li>
  </ul>

  </div>
</section>

  <footer id="footer">
    <img src="/img/me-torso-scaleway.png" class="footer-me" />
    <div class="footer-above">
        <div class="footer-col">
            <h3>Location</h3>
            <p>Lille<br>France</p>
        </div>
        <div class="footer-col">
            <h3>Around the Web</h3>
            <ul class="list-inline">
                <!-- <li>
                    <a href="https://www.goodreads.com/user/show/104485538-sobczak-julien" alt="Goodreads" title="Goodreads" class="btn-social btn-outline"><i class="fab fa-goodreads-g"></i></a>
                </li> -->
                <li>
                    <a href="https://literal.club/julien-sobczak" alt="Goodreads" title="Library.club" class="btn-social btn-outline"><i class="fa fa-book"></i></a>
                </li>
                <li>
                    <a href="https://github.com/julien-sobczak" alt="GitHub" title="GitHub" class="btn-social btn-outline"><i class="fab fa-github"></i></a>
                </li>
                <li>
                    <a href="https://fr.linkedin.com/in/julien-sobczak-56780a91" alt="LinkedIn" title="LinkedIn" class="btn-social btn-outline"><i class="fab fa-linkedin"></i></a>
                </li>
            </ul>
        </div>
    </div>
    <div class="footer-below">
        <span>Opinions are my own and don't reflect the views of my employer.</span><br/>
        <span class="manuscript">In addition, as anybody with an open mind, my opinions are likely to change from time to time...</span><br/><br/>
        <small class="copyright">Copyright &copy; 2024 Julien Sobczak</small><br/>
    </div>
</footer>

  <div id="easter-egg">
  <div id="water"></div>
  <div id="bikini-bottom">
    <img id="spongebob" src="/img/easter-egg/spongebob.png" width="20%">
  </div>
</div>
  <!-- Font Awesome CDN -->
<!-- <script src="https://kit.fontawesome.com/d54861fcaa.js" crossorigin="anonymous"></script> -->
<script src="/js/index.js"></script>

<!-- Masonry effect -->
<!-- <script src="https://unpkg.com/colcade@0/colcade.js"></script> -->
<script src="/vendor/fontawesome.js"></script>

<!-- Custom logic -->
<script src="/vendor/colcade.js"></script>


</body>
</html>
